[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "Hi, I am Priya Shanmugasundaram. This is my blog submission for CS 5805: Machine Learning final project. Happy Reading :)"
  },
  {
    "objectID": "index.html#the-normal-equation",
    "href": "index.html#the-normal-equation",
    "title": "Setup",
    "section": "The Normal Equation",
    "text": "The Normal Equation\n\nimport numpy as np\n\nnp.random.seed(42)  # to make this code example reproducible\nm = 100  # number of instances\nX = 2 * np.random.rand(m, 1)  # column vector\ny = 4 + 3 * X + np.random.randn(m, 1)  # column vector\n\n\n# extra code – generates and saves Figure 4–1\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"generated_data_plot\")\nplt.show()\n\n\n\n\n\nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)  # add x0 = 1 to each instance\ntheta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n\n\ntheta_best\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\nX_new = np.array([[0], [2]])\nX_new_b = add_dummy_feature(X_new)  # add x0 = 1 to each instance\ny_predict = X_new_b @ theta_best\ny_predict\n\narray([[4.21509616],\n       [9.75532293]])\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\nplt.plot(X_new, y_predict, \"r-\", label=\"Predictions\")\nplt.plot(X, y, \"b.\")\n\n# extra code – beautifies and saves Figure 4–2\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nplt.legend(loc=\"upper left\")\nsave_fig(\"linear_model_predictions_plot\")\n\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\n\nlin_reg = LinearRegression()\nlin_reg.fit(X, y)\nlin_reg.intercept_, lin_reg.coef_\n\n(array([4.21509616]), array([[2.77011339]]))\n\n\n\nlin_reg.predict(X_new)\n\narray([[4.21509616],\n       [9.75532293]])\n\n\nThe LinearRegression class is based on the scipy.linalg.lstsq() function (the name stands for “least squares”), which you could call directly:\n\ntheta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=1e-6)\ntheta_best_svd\n\narray([[4.21509616],\n       [2.77011339]])\n\n\nThis function computes \\(\\mathbf{X}^+\\mathbf{y}\\), where \\(\\mathbf{X}^{+}\\) is the pseudoinverse of \\(\\mathbf{X}\\) (specifically the Moore-Penrose inverse). You can use np.linalg.pinv() to compute the pseudoinverse directly:\n\nnp.linalg.pinv(X_b) @ y\n\narray([[4.21509616],\n       [2.77011339]])"
  },
  {
    "objectID": "index.html#batch-gradient-descent",
    "href": "index.html#batch-gradient-descent",
    "title": "Setup",
    "section": "Batch Gradient Descent",
    "text": "Batch Gradient Descent\n\neta = 0.1  # learning rate\nn_epochs = 1000\nm = len(X_b)  # number of instances\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # randomly initialized model parameters\n\nfor epoch in range(n_epochs):\n    gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n    theta = theta - eta * gradients\n\nThe trained model parameters:\n\ntheta\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\n# extra code – generates and saves Figure 4–8\n\nimport matplotlib as mpl\n\ndef plot_gradient_descent(theta, eta):\n    m = len(X_b)\n    plt.plot(X, y, \"b.\")\n    n_epochs = 1000\n    n_shown = 20\n    theta_path = []\n    for epoch in range(n_epochs):\n        if epoch &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(epoch / n_shown + 0.15))\n            plt.plot(X_new, y_predict, linestyle=\"solid\", color=color)\n        gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n        theta = theta - eta * gradients\n        theta_path.append(theta)\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 2, 0, 15])\n    plt.grid()\n    plt.title(fr\"$\\eta = {eta}$\")\n    return theta_path\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nplt.figure(figsize=(10, 4))\nplt.subplot(131)\nplot_gradient_descent(theta, eta=0.02)\nplt.ylabel(\"$y$\", rotation=0)\nplt.subplot(132)\ntheta_path_bgd = plot_gradient_descent(theta, eta=0.1)\nplt.gca().axes.yaxis.set_ticklabels([])\nplt.subplot(133)\nplt.gca().axes.yaxis.set_ticklabels([])\nplot_gradient_descent(theta, eta=0.5)\nsave_fig(\"gradient_descent_plot\")\nplt.show()"
  },
  {
    "objectID": "index.html#stochastic-gradient-descent",
    "href": "index.html#stochastic-gradient-descent",
    "title": "Setup",
    "section": "Stochastic Gradient Descent",
    "text": "Stochastic Gradient Descent\n\ntheta_path_sgd = []  # extra code – we need to store the path of theta in the\n                     #              parameter space to plot the next figure\n\n\nn_epochs = 50\nt0, t1 = 5, 50  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nn_shown = 20  # extra code – just needed to generate the figure below\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\n\nfor epoch in range(n_epochs):\n    for iteration in range(m):\n\n        # extra code – these 4 lines are used to generate the figure\n        if epoch == 0 and iteration &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(iteration / n_shown + 0.15))\n            plt.plot(X_new, y_predict, color=color)\n\n        random_index = np.random.randint(m)\n        xi = X_b[random_index : random_index + 1]\n        yi = y[random_index : random_index + 1]\n        gradients = 2 * xi.T @ (xi @ theta - yi)  # for SGD, do not divide by m\n        eta = learning_schedule(epoch * m + iteration)\n        theta = theta - eta * gradients\n        theta_path_sgd.append(theta)  # extra code – to generate the figure\n\n# extra code – this section beautifies and saves Figure 4–10\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"sgd_plot\")\nplt.show()\n\n\n\n\n\ntheta\n\narray([[4.21076011],\n       [2.74856079]])\n\n\n\nfrom sklearn.linear_model import SGDRegressor\n\nsgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, penalty=None, eta0=0.01,\n                       n_iter_no_change=100, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\n\nSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SGDRegressorSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)\n\n\n\nsgd_reg.intercept_, sgd_reg.coef_\n\n(array([4.21278812]), array([2.77270267]))"
  },
  {
    "objectID": "index.html#mini-batch-gradient-descent",
    "href": "index.html#mini-batch-gradient-descent",
    "title": "Setup",
    "section": "Mini-batch gradient descent",
    "text": "Mini-batch gradient descent\nThe code in this section is used to generate the next figure, it is not in the book.\n\n# extra code – this cell generates and saves Figure 4–11\n\nfrom math import ceil\n\nn_epochs = 50\nminibatch_size = 20\nn_batches_per_epoch = ceil(m / minibatch_size)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nt0, t1 = 200, 1000  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\ntheta_path_mgd = []\nfor epoch in range(n_epochs):\n    shuffled_indices = np.random.permutation(m)\n    X_b_shuffled = X_b[shuffled_indices]\n    y_shuffled = y[shuffled_indices]\n    for iteration in range(0, n_batches_per_epoch):\n        idx = iteration * minibatch_size\n        xi = X_b_shuffled[idx : idx + minibatch_size]\n        yi = y_shuffled[idx : idx + minibatch_size]\n        gradients = 2 / minibatch_size * xi.T @ (xi @ theta - yi)\n        eta = learning_schedule(iteration)\n        theta = theta - eta * gradients\n        theta_path_mgd.append(theta)\n\ntheta_path_bgd = np.array(theta_path_bgd)\ntheta_path_sgd = np.array(theta_path_sgd)\ntheta_path_mgd = np.array(theta_path_mgd)\n\nplt.figure(figsize=(7, 4))\nplt.plot(theta_path_sgd[:, 0], theta_path_sgd[:, 1], \"r-s\", linewidth=1,\n         label=\"Stochastic\")\nplt.plot(theta_path_mgd[:, 0], theta_path_mgd[:, 1], \"g-+\", linewidth=2,\n         label=\"Mini-batch\")\nplt.plot(theta_path_bgd[:, 0], theta_path_bgd[:, 1], \"b-o\", linewidth=3,\n         label=\"Batch\")\nplt.legend(loc=\"upper left\")\nplt.xlabel(r\"$\\theta_0$\")\nplt.ylabel(r\"$\\theta_1$   \", rotation=0)\nplt.axis([2.6, 4.6, 2.3, 3.4])\nplt.grid()\nsave_fig(\"gradient_descent_paths_plot\")\nplt.show()"
  },
  {
    "objectID": "index.html#ridge-regression",
    "href": "index.html#ridge-regression",
    "title": "Setup",
    "section": "Ridge Regression",
    "text": "Ridge Regression\nLet’s generate a very small and noisy linear dataset:\n\n# extra code – we've done this type of generation several times before\nnp.random.seed(42)\nm = 20\nX = 3 * np.random.rand(m, 1)\ny = 1 + 0.5 * X + np.random.randn(m, 1) / 1.5\nX_new = np.linspace(0, 3, 100).reshape(100, 1)\n\n\n# extra code – a quick peek at the dataset we just generated\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \".\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$  \", rotation=0)\nplt.axis([0, 3, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import Ridge\n\nridge_reg = Ridge(alpha=0.1, solver=\"cholesky\")\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55325833]])\n\n\n\n# extra code – this cell generates and saves Figure 4–17\n\ndef plot_model(model_class, polynomial, alphas, **model_kwargs):\n    plt.plot(X, y, \"b.\", linewidth=3)\n    for alpha, style in zip(alphas, (\"b:\", \"g--\", \"r-\")):\n        if alpha &gt; 0:\n            model = model_class(alpha, **model_kwargs)\n        else:\n            model = LinearRegression()\n        if polynomial:\n            model = make_pipeline(\n                PolynomialFeatures(degree=10, include_bias=False),\n                StandardScaler(),\n                model)\n        model.fit(X, y)\n        y_new_regul = model.predict(X_new)\n        plt.plot(X_new, y_new_regul, style, linewidth=2,\n                 label=fr\"$\\alpha = {alpha}$\")\n    plt.legend(loc=\"upper left\")\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 3, 0, 3.5])\n    plt.grid()\n\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Ridge, polynomial=False, alphas=(0, 10, 100), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Ridge, polynomial=True, alphas=(0, 10**-5, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"ridge_regression_plot\")\nplt.show()\n\n\n\n\n\nsgd_reg = SGDRegressor(penalty=\"l2\", alpha=0.1 / m, tol=None,\n                       max_iter=1000, eta0=0.01, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\nsgd_reg.predict([[1.5]])\n\narray([1.55302613])\n\n\n\n# extra code – show that we get roughly the same solution as earlier when\n#              we use Stochastic Average GD (solver=\"sag\")\nridge_reg = Ridge(alpha=0.1, solver=\"sag\", random_state=42)\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55326019]])\n\n\n\n# extra code – shows the closed form solution of Ridge regression,\n#              compare with the next Ridge model's learned parameters below\nalpha = 0.1\nA = np.array([[0., 0.], [0., 1.]])\nX_b = np.c_[np.ones(m), X]\nnp.linalg.inv(X_b.T @ X_b + alpha * A) @ X_b.T @ y\n\narray([[0.97898394],\n       [0.3828496 ]])\n\n\n\nridge_reg.intercept_, ridge_reg.coef_  # extra code\n\n(array([0.97896386]), array([[0.38286422]]))"
  },
  {
    "objectID": "index.html#lasso-regression",
    "href": "index.html#lasso-regression",
    "title": "Setup",
    "section": "Lasso Regression",
    "text": "Lasso Regression\n\nfrom sklearn.linear_model import Lasso\n\nlasso_reg = Lasso(alpha=0.1)\nlasso_reg.fit(X, y)\nlasso_reg.predict([[1.5]])\n\narray([1.53788174])\n\n\n\n# extra code – this cell generates and saves Figure 4–18\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Lasso, polynomial=False, alphas=(0, 0.1, 1), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Lasso, polynomial=True, alphas=(0, 1e-2, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"lasso_regression_plot\")\nplt.show()\n\n\n\n\n\n# extra code – this BIG cell generates and saves Figure 4–19\n\nt1a, t1b, t2a, t2b = -1, 3, -1.5, 1.5\n\nt1s = np.linspace(t1a, t1b, 500)\nt2s = np.linspace(t2a, t2b, 500)\nt1, t2 = np.meshgrid(t1s, t2s)\nT = np.c_[t1.ravel(), t2.ravel()]\nXr = np.array([[1, 1], [1, -1], [1, 0.5]])\nyr = 2 * Xr[:, :1] + 0.5 * Xr[:, 1:]\n\nJ = (1 / len(Xr) * ((T @ Xr.T - yr.T) ** 2).sum(axis=1)).reshape(t1.shape)\n\nN1 = np.linalg.norm(T, ord=1, axis=1).reshape(t1.shape)\nN2 = np.linalg.norm(T, ord=2, axis=1).reshape(t1.shape)\n\nt_min_idx = np.unravel_index(J.argmin(), J.shape)\nt1_min, t2_min = t1[t_min_idx], t2[t_min_idx]\n\nt_init = np.array([[0.25], [-1]])\n\ndef bgd_path(theta, X, y, l1, l2, core=1, eta=0.05, n_iterations=200):\n    path = [theta]\n    for iteration in range(n_iterations):\n        gradients = (core * 2 / len(X) * X.T @ (X @ theta - y)\n                     + l1 * np.sign(theta) + l2 * theta)\n        theta = theta - eta * gradients\n        path.append(theta)\n    return np.array(path)\n\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(10.1, 8))\n\nfor i, N, l1, l2, title in ((0, N1, 2.0, 0, \"Lasso\"), (1, N2, 0, 2.0, \"Ridge\")):\n    JR = J + l1 * N1 + l2 * 0.5 * N2 ** 2\n\n    tr_min_idx = np.unravel_index(JR.argmin(), JR.shape)\n    t1r_min, t2r_min = t1[tr_min_idx], t2[tr_min_idx]\n\n    levels = np.exp(np.linspace(0, 1, 20)) - 1\n    levelsJ = levels * (J.max() - J.min()) + J.min()\n    levelsJR = levels * (JR.max() - JR.min()) + JR.min()\n    levelsN = np.linspace(0, N.max(), 10)\n\n    path_J = bgd_path(t_init, Xr, yr, l1=0, l2=0)\n    path_JR = bgd_path(t_init, Xr, yr, l1, l2)\n    path_N = bgd_path(theta=np.array([[2.0], [0.5]]), X=Xr, y=yr,\n                      l1=np.sign(l1) / 3, l2=np.sign(l2), core=0)\n    ax = axes[i, 0]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, N / 2.0, levels=levelsN)\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.set_title(fr\"$\\ell_{i + 1}$ penalty\")\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n    ax.set_ylabel(r\"$\\theta_2$\", rotation=0)\n\n    ax = axes[i, 1]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, JR, levels=levelsJR, alpha=0.9)\n    ax.plot(path_JR[:, 0], path_JR[:, 1], \"w-o\")\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.plot(t1r_min, t2r_min, \"rs\")\n    ax.set_title(title)\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n\nsave_fig(\"lasso_vs_ridge_plot\")\nplt.show()"
  },
  {
    "objectID": "index.html#elastic-net",
    "href": "index.html#elastic-net",
    "title": "Setup",
    "section": "Elastic Net",
    "text": "Elastic Net\n\nfrom sklearn.linear_model import ElasticNet\n\nelastic_net = ElasticNet(alpha=0.1, l1_ratio=0.5)\nelastic_net.fit(X, y)\nelastic_net.predict([[1.5]])\n\narray([1.54333232])"
  },
  {
    "objectID": "index.html#early-stopping",
    "href": "index.html#early-stopping",
    "title": "Setup",
    "section": "Early Stopping",
    "text": "Early Stopping\nLet’s go back to the quadratic dataset we used earlier:\n\nfrom copy import deepcopy\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# extra code – creates the same quadratic dataset as earlier and splits it\nnp.random.seed(42)\nm = 100\nX = 6 * np.random.rand(m, 1) - 3\ny = 0.5 * X ** 2 + X + 2 + np.random.randn(m, 1)\nX_train, y_train = X[: m // 2], y[: m // 2, 0]\nX_valid, y_valid = X[m // 2 :], y[m // 2 :, 0]\n\npreprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False),\n                              StandardScaler())\nX_train_prep = preprocessing.fit_transform(X_train)\nX_valid_prep = preprocessing.transform(X_valid)\nsgd_reg = SGDRegressor(penalty=None, eta0=0.002, random_state=42)\nn_epochs = 500\nbest_valid_rmse = float('inf')\ntrain_errors, val_errors = [], []  # extra code – it's for the figure below\n\nfor epoch in range(n_epochs):\n    sgd_reg.partial_fit(X_train_prep, y_train)\n    y_valid_predict = sgd_reg.predict(X_valid_prep)\n    val_error = mean_squared_error(y_valid, y_valid_predict, squared=False)\n    if val_error &lt; best_valid_rmse:\n        best_valid_rmse = val_error\n        best_model = deepcopy(sgd_reg)\n\n    # extra code – we evaluate the train error and save it for the figure\n    y_train_predict = sgd_reg.predict(X_train_prep)\n    train_error = mean_squared_error(y_train, y_train_predict, squared=False)\n    val_errors.append(val_error)\n    train_errors.append(train_error)\n\n# extra code – this section generates and saves Figure 4–20\nbest_epoch = np.argmin(val_errors)\nplt.figure(figsize=(6, 4))\nplt.annotate('Best model',\n             xy=(best_epoch, best_valid_rmse),\n             xytext=(best_epoch, best_valid_rmse + 0.5),\n             ha=\"center\",\n             arrowprops=dict(facecolor='black', shrink=0.05))\nplt.plot([0, n_epochs], [best_valid_rmse, best_valid_rmse], \"k:\", linewidth=2)\nplt.plot(val_errors, \"b-\", linewidth=3, label=\"Validation set\")\nplt.plot(best_epoch, best_valid_rmse, \"bo\")\nplt.plot(train_errors, \"r--\", linewidth=2, label=\"Training set\")\nplt.legend(loc=\"upper right\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"RMSE\")\nplt.axis([0, n_epochs, 0, 3.5])\nplt.grid()\nsave_fig(\"early_stopping_plot\")\nplt.show()"
  },
  {
    "objectID": "index.html#estimating-probabilities",
    "href": "index.html#estimating-probabilities",
    "title": "Setup",
    "section": "Estimating Probabilities",
    "text": "Estimating Probabilities\n\n# extra code – generates and saves Figure 4–21\n\nlim = 6\nt = np.linspace(-lim, lim, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.figure(figsize=(8, 3))\nplt.plot([-lim, lim], [0, 0], \"k-\")\nplt.plot([-lim, lim], [0.5, 0.5], \"k:\")\nplt.plot([-lim, lim], [1, 1], \"k:\")\nplt.plot([0, 0], [-1.1, 1.1], \"k-\")\nplt.plot(t, sig, \"b-\", linewidth=2, label=r\"$\\sigma(t) = \\dfrac{1}{1 + e^{-t}}$\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.axis([-lim, lim, -0.1, 1.1])\nplt.gca().set_yticks([0, 0.25, 0.5, 0.75, 1])\nplt.grid()\nsave_fig(\"logistic_function_plot\")\nplt.show()"
  },
  {
    "objectID": "index.html#decision-boundaries",
    "href": "index.html#decision-boundaries",
    "title": "Setup",
    "section": "Decision Boundaries",
    "text": "Decision Boundaries\n\nfrom sklearn.datasets import load_iris\n\niris = load_iris(as_frame=True)\nlist(iris)\n\n['data',\n 'target',\n 'frame',\n 'target_names',\n 'DESCR',\n 'feature_names',\n 'filename',\n 'data_module']\n\n\n\nprint(iris.DESCR)  # extra code – it's a bit too long\n\n.. _iris_dataset:\n\nIris plants dataset\n--------------------\n\n**Data Set Characteristics:**\n\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n                \n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThe famous Iris database, first used by Sir R.A. Fisher. The dataset is taken\nfrom Fisher's paper. Note that it's the same as in R, but not as in the UCI\nMachine Learning Repository, which has two wrong data points.\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher's paper is a classic in the field and\nis referenced frequently to this day.  (See Duda & Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\n|details-start|\n**References**\n|details-split|\n\n- Fisher, R.A. \"The use of multiple measurements in taxonomic problems\"\n  Annual Eugenics, 7, Part II, 179-188 (1936); also in \"Contributions to\n  Mathematical Statistics\" (John Wiley, NY, 1950).\n- Duda, R.O., & Hart, P.E. (1973) Pattern Classification and Scene Analysis.\n  (Q327.D83) John Wiley & Sons.  ISBN 0-471-22361-1.  See page 218.\n- Dasarathy, B.V. (1980) \"Nosing Around the Neighborhood: A New System\n  Structure and Classification Rule for Recognition in Partially Exposed\n  Environments\".  IEEE Transactions on Pattern Analysis and Machine\n  Intelligence, Vol. PAMI-2, No. 1, 67-71.\n- Gates, G.W. (1972) \"The Reduced Nearest Neighbor Rule\".  IEEE Transactions\n  on Information Theory, May 1972, 431-433.\n- See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al\"s AUTOCLASS II\n  conceptual clustering system finds 3 classes in the data.\n- Many, many more ...\n\n|details-end|\n\n\n\niris.data.head(3)\n\n\n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n\n\n\n\n\n\niris.target.head(3)  # note that the instances are not shuffled\n\n0    0\n1    0\n2    0\nName: target, dtype: int64\n\n\n\niris.target_names\n\narray(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')\n\n\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\n\nX = iris.data[[\"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(random_state=42)\nlog_reg.fit(X_train, y_train)\n\nLogisticRegression(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=42)\n\n\n\nX_new = np.linspace(0, 3, 1000).reshape(-1, 1)  # reshape to get a column vector\ny_proba = log_reg.predict_proba(X_new)\ndecision_boundary = X_new[y_proba[:, 1] &gt;= 0.5][0, 0]\n\nplt.figure(figsize=(8, 3))  # extra code – not needed, just formatting\nplt.plot(X_new, y_proba[:, 0], \"b--\", linewidth=2,\n         label=\"Not Iris virginica proba\")\nplt.plot(X_new, y_proba[:, 1], \"g-\", linewidth=2, label=\"Iris virginica proba\")\nplt.plot([decision_boundary, decision_boundary], [0, 1], \"k:\", linewidth=2,\n         label=\"Decision boundary\")\n\n# extra code – this section beautifies and saves Figure 4–23\nplt.arrow(x=decision_boundary, y=0.08, dx=-0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"b\", ec=\"b\")\nplt.arrow(x=decision_boundary, y=0.92, dx=0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"g\", ec=\"g\")\nplt.plot(X_train[y_train == 0], y_train[y_train == 0], \"bs\")\nplt.plot(X_train[y_train == 1], y_train[y_train == 1], \"g^\")\nplt.xlabel(\"Petal width (cm)\")\nplt.ylabel(\"Probability\")\nplt.legend(loc=\"center left\")\nplt.axis([0, 3, -0.02, 1.02])\nplt.grid()\nsave_fig(\"logistic_regression_plot\")\n\nplt.show()\n\n\n\n\n\ndecision_boundary\n\n1.6516516516516517\n\n\n\nlog_reg.predict([[1.7], [1.5]])\n\narray([ True, False])\n\n\n\n# extra code – this cell generates and saves Figure 4–24\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(C=2, random_state=42)\nlog_reg.fit(X_train, y_train)\n\n# for the contour plot\nx0, x1 = np.meshgrid(np.linspace(2.9, 7, 500).reshape(-1, 1),\n                     np.linspace(0.8, 2.7, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]  # one instance per point on the figure\ny_proba = log_reg.predict_proba(X_new)\nzz = y_proba[:, 1].reshape(x0.shape)\n\n# for the decision boundary\nleft_right = np.array([2.9, 7])\nboundary = -((log_reg.coef_[0, 0] * left_right + log_reg.intercept_[0])\n             / log_reg.coef_[0, 1])\n\nplt.figure(figsize=(10, 4))\nplt.plot(X_train[y_train == 0, 0], X_train[y_train == 0, 1], \"bs\")\nplt.plot(X_train[y_train == 1, 0], X_train[y_train == 1, 1], \"g^\")\ncontour = plt.contour(x0, x1, zz, cmap=plt.cm.brg)\nplt.clabel(contour, inline=1)\nplt.plot(left_right, boundary, \"k--\", linewidth=3)\nplt.text(3.5, 1.27, \"Not Iris virginica\", color=\"b\", ha=\"center\")\nplt.text(6.5, 2.3, \"Iris virginica\", color=\"g\", ha=\"center\")\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.axis([2.9, 7, 0.8, 2.7])\nplt.grid()\nsave_fig(\"logistic_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "index.html#softmax-regression",
    "href": "index.html#softmax-regression",
    "title": "Setup",
    "section": "Softmax Regression",
    "text": "Softmax Regression\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nsoftmax_reg = LogisticRegression(C=30, random_state=42)\nsoftmax_reg.fit(X_train, y_train)\n\nLogisticRegression(C=30, random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(C=30, random_state=42)\n\n\n\nsoftmax_reg.predict([[5, 2]])\n\narray([2])\n\n\n\nsoftmax_reg.predict_proba([[5, 2]]).round(2)\n\narray([[0.  , 0.04, 0.96]])\n\n\n\n# extra code – this cell generates and saves Figure 4–25\n\nfrom matplotlib.colors import ListedColormap\n\ncustom_cmap = ListedColormap([\"#fafab0\", \"#9898ff\", \"#a0faa0\"])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\n\ny_proba = softmax_reg.predict_proba(X_new)\ny_predict = softmax_reg.predict(X_new)\n\nzz1 = y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"center left\")\nplt.axis([0.5, 7, 0, 3.5])\nplt.grid()\nsave_fig(\"softmax_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "index.html#to-11.",
    "href": "index.html#to-11.",
    "title": "Setup",
    "section": "1. to 11.",
    "text": "1. to 11.\n\nIf you have a training set with millions of features you can use Stochastic Gradient Descent or Mini-batch Gradient Descent, and perhaps Batch Gradient Descent if the training set fits in memory. But you cannot use the Normal Equation or the SVD approach because the computational complexity grows quickly (more than quadratically) with the number of features.\nIf the features in your training set have very different scales, the cost function will have the shape of an elongated bowl, so the Gradient Descent algorithms will take a long time to converge. To solve this you should scale the data before training the model. Note that the Normal Equation or SVD approach will work just fine without scaling. Moreover, regularized models may converge to a suboptimal solution if the features are not scaled: since regularization penalizes large weights, features with smaller values will tend to be ignored compared to features with larger values.\nGradient Descent cannot get stuck in a local minimum when training a Logistic Regression model because the cost function is convex. Convex means that if you draw a straight line between any two points on the curve, the line never crosses the curve.\nIf the optimization problem is convex (such as Linear Regression or Logistic Regression), and assuming the learning rate is not too high, then all Gradient Descent algorithms will approach the global optimum and end up producing fairly similar models. However, unless you gradually reduce the learning rate, Stochastic GD and Mini-batch GD will never truly converge; instead, they will keep jumping back and forth around the global optimum. This means that even if you let them run for a very long time, these Gradient Descent algorithms will produce slightly different models.\nIf the validation error consistently goes up after every epoch, then one possibility is that the learning rate is too high and the algorithm is diverging. If the training error also goes up, then this is clearly the problem and you should reduce the learning rate. However, if the training error is not going up, then your model is overfitting the training set and you should stop training.\nDue to their random nature, neither Stochastic Gradient Descent nor Mini-batch Gradient Descent is guaranteed to make progress at every single training iteration. So if you immediately stop training when the validation error goes up, you may stop much too early, before the optimum is reached. A better option is to save the model at regular intervals; then, when it has not improved for a long time (meaning it will probably never beat the record), you can revert to the best saved model.\nStochastic Gradient Descent has the fastest training iteration since it considers only one training instance at a time, so it is generally the first to reach the vicinity of the global optimum (or Mini-batch GD with a very small mini-batch size). However, only Batch Gradient Descent will actually converge, given enough training time. As mentioned, Stochastic GD and Mini-batch GD will bounce around the optimum, unless you gradually reduce the learning rate.\nIf the validation error is much higher than the training error, this is likely because your model is overfitting the training set. One way to try to fix this is to reduce the polynomial degree: a model with fewer degrees of freedom is less likely to overfit. Another thing you can try is to regularize the model—for example, by adding an ℓ₂ penalty (Ridge) or an ℓ₁ penalty (Lasso) to the cost function. This will also reduce the degrees of freedom of the model. Lastly, you can try to increase the size of the training set.\nIf both the training error and the validation error are almost equal and fairly high, the model is likely underfitting the training set, which means it has a high bias. You should try reducing the regularization hyperparameter α.\nLet’s see:\n\n\nA model with some regularization typically performs better than a model without any regularization, so you should generally prefer Ridge Regression over plain Linear Regression.\nLasso Regression uses an ℓ₁ penalty, which tends to push the weights down to exactly zero. This leads to sparse models, where all weights are zero except for the most important weights. This is a way to perform feature selection automatically, which is good if you suspect that only a few features actually matter. When you are not sure, you should prefer Ridge Regression.\nElastic Net is generally preferred over Lasso since Lasso may behave erratically in some cases (when several features are strongly correlated or when there are more features than training instances). However, it does add an extra hyperparameter to tune. If you want Lasso without the erratic behavior, you can just use Elastic Net with an l1_ratio close to 1.\n\n\nIf you want to classify pictures as outdoor/indoor and daytime/nighttime, since these are not exclusive classes (i.e., all four combinations are possible) you should train two Logistic Regression classifiers."
  },
  {
    "objectID": "index.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "href": "index.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "title": "Setup",
    "section": "12. Batch Gradient Descent with early stopping for Softmax Regression",
    "text": "12. Batch Gradient Descent with early stopping for Softmax Regression\nExercise: Implement Batch Gradient Descent with early stopping for Softmax Regression without using Scikit-Learn, only NumPy. Use it on a classification task such as the iris dataset.\nLet’s start by loading the data. We will just reuse the Iris dataset we loaded earlier.\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"].values\n\nWe need to add the bias term for every instance (\\(x_0 = 1\\)). The easiest option to do this would be to use Scikit-Learn’s add_dummy_feature() function, but the point of this exercise is to get a better understanding of the algorithms by implementing them manually. So here is one possible implementation:\n\nX_with_bias = np.c_[np.ones(len(X)), X]\n\nThe easiest option to split the dataset into a training set, a validation set and a test set would be to use Scikit-Learn’s train_test_split() function, but again, we want to do it manually:\n\ntest_ratio = 0.2\nvalidation_ratio = 0.2\ntotal_size = len(X_with_bias)\n\ntest_size = int(total_size * test_ratio)\nvalidation_size = int(total_size * validation_ratio)\ntrain_size = total_size - test_size - validation_size\n\nnp.random.seed(42)\nrnd_indices = np.random.permutation(total_size)\n\nX_train = X_with_bias[rnd_indices[:train_size]]\ny_train = y[rnd_indices[:train_size]]\nX_valid = X_with_bias[rnd_indices[train_size:-test_size]]\ny_valid = y[rnd_indices[train_size:-test_size]]\nX_test = X_with_bias[rnd_indices[-test_size:]]\ny_test = y[rnd_indices[-test_size:]]\n\nThe targets are currently class indices (0, 1 or 2), but we need target class probabilities to train the Softmax Regression model. Each instance will have target class probabilities equal to 0.0 for all classes except for the target class which will have a probability of 1.0 (in other words, the vector of class probabilities for any given instance is a one-hot vector). Let’s write a small function to convert the vector of class indices into a matrix containing a one-hot vector for each instance. To understand this code, you need to know that np.diag(np.ones(n)) creates an n×n matrix full of 0s except for 1s on the main diagonal. Moreover, if a is a NumPy array, then a[[1, 3, 2]] returns an array with 3 rows equal to a[1], a[3] and a[2] (this is advanced NumPy indexing).\n\ndef to_one_hot(y):\n    return np.diag(np.ones(y.max() + 1))[y]\n\nLet’s test this function on the first 10 instances:\n\ny_train[:10]\n\narray([1, 0, 2, 1, 1, 0, 1, 2, 1, 1])\n\n\n\nto_one_hot(y_train[:10])\n\narray([[0., 1., 0.],\n       [1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.],\n       [1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.]])\n\n\nLooks good, so let’s create the target class probabilities matrix for the training set and the test set:\n\nY_train_one_hot = to_one_hot(y_train)\nY_valid_one_hot = to_one_hot(y_valid)\nY_test_one_hot = to_one_hot(y_test)\n\nNow let’s scale the inputs. We compute the mean and standard deviation of each feature on the training set (except for the bias feature), then we center and scale each feature in the training set, the validation set, and the test set:\n\nmean = X_train[:, 1:].mean(axis=0)\nstd = X_train[:, 1:].std(axis=0)\nX_train[:, 1:] = (X_train[:, 1:] - mean) / std\nX_valid[:, 1:] = (X_valid[:, 1:] - mean) / std\nX_test[:, 1:] = (X_test[:, 1:] - mean) / std\n\nNow let’s implement the Softmax function. Recall that it is defined by the following equation:\n\\(\\sigma\\left(\\mathbf{s}(\\mathbf{x})\\right)_k = \\dfrac{\\exp\\left(s_k(\\mathbf{x})\\right)}{\\sum\\limits_{j=1}^{K}{\\exp\\left(s_j(\\mathbf{x})\\right)}}\\)\n\ndef softmax(logits):\n    exps = np.exp(logits)\n    exp_sums = exps.sum(axis=1, keepdims=True)\n    return exps / exp_sums\n\nWe are almost ready to start training. Let’s define the number of inputs and outputs:\n\nn_inputs = X_train.shape[1]  # == 3 (2 features plus the bias term)\nn_outputs = len(np.unique(y_train))  # == 3 (there are 3 iris classes)\n\nNow here comes the hardest part: training! Theoretically, it’s simple: it’s just a matter of translating the math equations into Python code. But in practice, it can be quite tricky: in particular, it’s easy to mix up the order of the terms, or the indices. You can even end up with code that looks like it’s working but is actually not computing exactly the right thing. When unsure, you should write down the shape of each term in the equation and make sure the corresponding terms in your code match closely. It can also help to evaluate each term independently and print them out. The good news it that you won’t have to do this everyday, since all this is well implemented by Scikit-Learn, but it will help you understand what’s going on under the hood.\nSo the equations we will need are the cost function:\n\\(J(\\mathbf{\\Theta}) = - \\dfrac{1}{m}\\sum\\limits_{i=1}^{m}\\sum\\limits_{k=1}^{K}{y_k^{(i)}\\log\\left(\\hat{p}_k^{(i)}\\right)}\\)\nAnd the equation for the gradients:\n\\(\\nabla_{\\mathbf{\\theta}^{(k)}} \\, J(\\mathbf{\\Theta}) = \\dfrac{1}{m} \\sum\\limits_{i=1}^{m}{ \\left ( \\hat{p}^{(i)}_k - y_k^{(i)} \\right ) \\mathbf{x}^{(i)}}\\)\nNote that \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) may not be computable if \\(\\hat{p}_k^{(i)} = 0\\). So we will add a tiny value \\(\\epsilon\\) to \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) to avoid getting nan values.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        print(epoch, xentropy_losses.sum(axis=1).mean())\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    Theta = Theta - eta * gradients\n\n0 3.7085808486476917\n1000 0.14519367480830647\n2000 0.13013095755040877\n3000 0.12009639326384532\n4000 0.11372961364786878\n5000 0.11002459532472424\n\n\nAnd that’s it! The Softmax model is trained. Let’s look at the model parameters:\n\nTheta\n\narray([[ 0.41931626,  6.11112089, -5.52429876],\n       [-6.53054533, -0.74608616,  8.33137102],\n       [-5.28115784,  0.25152675,  6.90680425]])\n\n\nLet’s make predictions for the validation set and check the accuracy score:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nWell, this model looks pretty ok. For the sake of the exercise, let’s add a bit of \\(\\ell_2\\) regularization. The following training code is similar to the one above, but the loss now has an additional \\(\\ell_2\\) penalty, and the gradients have the proper additional term (note that we don’t regularize the first element of Theta since this corresponds to the bias term). Also, let’s try increasing the learning rate eta.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\nalpha = 0.01  # regularization hyperparameter\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n        total_loss = xentropy_losses.sum(axis=1).mean() + alpha * l2_loss\n        print(epoch, total_loss.round(4))\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n1000 0.3259\n2000 0.3259\n3000 0.3259\n4000 0.3259\n5000 0.3259\n\n\nBecause of the additional \\(\\ell_2\\) penalty, the loss seems greater than earlier, but perhaps this model will perform better? Let’s find out:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nIn this case, the \\(\\ell_2\\) penalty did not change the test accuracy. Perhaps try fine-tuning alpha?\nNow let’s add early stopping. For this we just need to measure the loss on the validation set at every iteration and stop when the error starts growing.\n\neta = 0.5\nn_epochs = 50_001\nm = len(X_train)\nepsilon = 1e-5\nC = 100  # regularization hyperparameter\nbest_loss = np.infty\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    Y_proba_valid = softmax(X_valid @ Theta)\n    xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n    l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n    total_loss = xentropy_losses.sum(axis=1).mean() + 1 / C * l2_loss\n    if epoch % 1000 == 0:\n        print(epoch, total_loss.round(4))\n    if total_loss &lt; best_loss:\n        best_loss = total_loss\n    else:\n        print(epoch - 1, best_loss.round(4))\n        print(epoch, total_loss.round(4), \"early stopping!\")\n        break\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), 1 / C * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n281 0.3256\n282 0.3256 early stopping!\n\n\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nOh well, still no change in validation accuracy, but at least early stopping shortened training a bit.\nNow let’s plot the model’s predictions on the whole dataset (remember to scale all features fed to the model):\n\ncustom_cmap = mpl.colors.ListedColormap(['#fafab0', '#9898ff', '#a0faa0'])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\nX_new = (X_new - mean) / std\nX_new_with_bias = np.c_[np.ones(len(X_new)), X_new]\n\nlogits = X_new_with_bias @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\nzz1 = Y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"upper left\")\nplt.axis([0, 7, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\nAnd now let’s measure the final model’s accuracy on the test set:\n\nlogits = X_test @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_test).mean()\naccuracy_score\n\n0.9666666666666667\n\n\nWell we get even better performance on the test set. This variability is likely due to the very small size of the dataset: depending on how you sample the training set, validation set and the test set, you can get quite different results. Try changing the random seed and running the code again a few times, you will see that the results will vary."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Probability Theory and Random Variables",
    "section": "",
    "text": "In the tapestry of our daily experiences, uncertainty weaves its intricate threads, creating a landscape where the unknown is an ever-present companion. From deciding whether to carry an umbrella to predicting stock market trends, uncertainty surrounds us, shaping our decisions, actions, and perceptions. It is this pervasive uncertainty that beckons us to explore the realm of probability theory, a powerful tool that empowers us to navigate the unpredictable nature of the world.\nEnter probability theory, a mathematical framework designed to bring order to the chaos of uncertainty. Probability theory provides us with a systematic way to quantify and analyze uncertainty, offering a language to express the likelihood of different outcomes. It serves as a compass, guiding us through the fog of unpredictability and enabling us to make informed decisions in the face of ambiguity.\nAt its core, probability theory explores the likelihood of events occurring in various situations. It equips us with the means to assign numerical values to the uncertainty inherent in any scenario, allowing us to make reasoned predictions and choices. Whether predicting the outcome of a dice roll or estimating the probability of a rare disease occurrence, probability theory provides the analytical tools essential for decision-making in uncertain environments.\nIn the following exploration of probability theory and random variables, we will unravel the intricacies of this indispensable field, delving into its fundamental concepts, applications in real life, and the ways it shapes our understanding of uncertainty. Join us on this journey as we unveil the mathematical underpinnings that empower us to confront the unpredictable with confidence and insight."
  },
  {
    "objectID": "about.html#the-normal-equation",
    "href": "about.html#the-normal-equation",
    "title": "Probability Theory and Random Variables",
    "section": "The Normal Equation",
    "text": "The Normal Equation\n\nimport numpy as np\n\nnp.random.seed(42)  # to make this code example reproducible\nm = 100  # number of instances\nX = 2 * np.random.rand(m, 1)  # column vector\ny = 4 + 3 * X + np.random.randn(m, 1)  # column vector\n\n\n# extra code – generates and saves Figure 4–1\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"generated_data_plot\")\nplt.show()\n\n\n\n\n\nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)  # add x0 = 1 to each instance\ntheta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n\n\ntheta_best\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\nX_new = np.array([[0], [2]])\nX_new_b = add_dummy_feature(X_new)  # add x0 = 1 to each instance\ny_predict = X_new_b @ theta_best\ny_predict\n\narray([[4.21509616],\n       [9.75532293]])\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\nplt.plot(X_new, y_predict, \"r-\", label=\"Predictions\")\nplt.plot(X, y, \"b.\")\n\n# extra code – beautifies and saves Figure 4–2\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nplt.legend(loc=\"upper left\")\nsave_fig(\"linear_model_predictions_plot\")\n\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\n\nlin_reg = LinearRegression()\nlin_reg.fit(X, y)\nlin_reg.intercept_, lin_reg.coef_\n\n(array([4.21509616]), array([[2.77011339]]))\n\n\n\nlin_reg.predict(X_new)\n\narray([[4.21509616],\n       [9.75532293]])\n\n\nThe LinearRegression class is based on the scipy.linalg.lstsq() function (the name stands for “least squares”), which you could call directly:\n\ntheta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=1e-6)\ntheta_best_svd\n\narray([[4.21509616],\n       [2.77011339]])\n\n\nThis function computes \\(\\mathbf{X}^+\\mathbf{y}\\), where \\(\\mathbf{X}^{+}\\) is the pseudoinverse of \\(\\mathbf{X}\\) (specifically the Moore-Penrose inverse). You can use np.linalg.pinv() to compute the pseudoinverse directly:\n\nnp.linalg.pinv(X_b) @ y\n\narray([[4.21509616],\n       [2.77011339]])"
  },
  {
    "objectID": "about.html#batch-gradient-descent",
    "href": "about.html#batch-gradient-descent",
    "title": "Probability Theory and Random Variables",
    "section": "Batch Gradient Descent",
    "text": "Batch Gradient Descent\n\neta = 0.1  # learning rate\nn_epochs = 1000\nm = len(X_b)  # number of instances\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # randomly initialized model parameters\n\nfor epoch in range(n_epochs):\n    gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n    theta = theta - eta * gradients\n\nThe trained model parameters:\n\ntheta\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\n# extra code – generates and saves Figure 4–8\n\nimport matplotlib as mpl\n\ndef plot_gradient_descent(theta, eta):\n    m = len(X_b)\n    plt.plot(X, y, \"b.\")\n    n_epochs = 1000\n    n_shown = 20\n    theta_path = []\n    for epoch in range(n_epochs):\n        if epoch &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(epoch / n_shown + 0.15))\n            plt.plot(X_new, y_predict, linestyle=\"solid\", color=color)\n        gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n        theta = theta - eta * gradients\n        theta_path.append(theta)\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 2, 0, 15])\n    plt.grid()\n    plt.title(fr\"$\\eta = {eta}$\")\n    return theta_path\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nplt.figure(figsize=(10, 4))\nplt.subplot(131)\nplot_gradient_descent(theta, eta=0.02)\nplt.ylabel(\"$y$\", rotation=0)\nplt.subplot(132)\ntheta_path_bgd = plot_gradient_descent(theta, eta=0.1)\nplt.gca().axes.yaxis.set_ticklabels([])\nplt.subplot(133)\nplt.gca().axes.yaxis.set_ticklabels([])\nplot_gradient_descent(theta, eta=0.5)\nsave_fig(\"gradient_descent_plot\")\nplt.show()"
  },
  {
    "objectID": "about.html#stochastic-gradient-descent",
    "href": "about.html#stochastic-gradient-descent",
    "title": "Probability Theory and Random Variables",
    "section": "Stochastic Gradient Descent",
    "text": "Stochastic Gradient Descent\n\ntheta_path_sgd = []  # extra code – we need to store the path of theta in the\n                     #              parameter space to plot the next figure\n\n\nn_epochs = 50\nt0, t1 = 5, 50  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nn_shown = 20  # extra code – just needed to generate the figure below\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\n\nfor epoch in range(n_epochs):\n    for iteration in range(m):\n\n        # extra code – these 4 lines are used to generate the figure\n        if epoch == 0 and iteration &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(iteration / n_shown + 0.15))\n            plt.plot(X_new, y_predict, color=color)\n\n        random_index = np.random.randint(m)\n        xi = X_b[random_index : random_index + 1]\n        yi = y[random_index : random_index + 1]\n        gradients = 2 * xi.T @ (xi @ theta - yi)  # for SGD, do not divide by m\n        eta = learning_schedule(epoch * m + iteration)\n        theta = theta - eta * gradients\n        theta_path_sgd.append(theta)  # extra code – to generate the figure\n\n# extra code – this section beautifies and saves Figure 4–10\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"sgd_plot\")\nplt.show()\n\n\n\n\n\ntheta\n\narray([[4.21076011],\n       [2.74856079]])\n\n\n\nfrom sklearn.linear_model import SGDRegressor\n\nsgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, penalty=None, eta0=0.01,\n                       n_iter_no_change=100, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\n\nSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SGDRegressorSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)\n\n\n\nsgd_reg.intercept_, sgd_reg.coef_\n\n(array([4.21278812]), array([2.77270267]))"
  },
  {
    "objectID": "about.html#mini-batch-gradient-descent",
    "href": "about.html#mini-batch-gradient-descent",
    "title": "Probability Theory and Random Variables",
    "section": "Mini-batch gradient descent",
    "text": "Mini-batch gradient descent\nThe code in this section is used to generate the next figure, it is not in the book.\n\n# extra code – this cell generates and saves Figure 4–11\n\nfrom math import ceil\n\nn_epochs = 50\nminibatch_size = 20\nn_batches_per_epoch = ceil(m / minibatch_size)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nt0, t1 = 200, 1000  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\ntheta_path_mgd = []\nfor epoch in range(n_epochs):\n    shuffled_indices = np.random.permutation(m)\n    X_b_shuffled = X_b[shuffled_indices]\n    y_shuffled = y[shuffled_indices]\n    for iteration in range(0, n_batches_per_epoch):\n        idx = iteration * minibatch_size\n        xi = X_b_shuffled[idx : idx + minibatch_size]\n        yi = y_shuffled[idx : idx + minibatch_size]\n        gradients = 2 / minibatch_size * xi.T @ (xi @ theta - yi)\n        eta = learning_schedule(iteration)\n        theta = theta - eta * gradients\n        theta_path_mgd.append(theta)\n\ntheta_path_bgd = np.array(theta_path_bgd)\ntheta_path_sgd = np.array(theta_path_sgd)\ntheta_path_mgd = np.array(theta_path_mgd)\n\nplt.figure(figsize=(7, 4))\nplt.plot(theta_path_sgd[:, 0], theta_path_sgd[:, 1], \"r-s\", linewidth=1,\n         label=\"Stochastic\")\nplt.plot(theta_path_mgd[:, 0], theta_path_mgd[:, 1], \"g-+\", linewidth=2,\n         label=\"Mini-batch\")\nplt.plot(theta_path_bgd[:, 0], theta_path_bgd[:, 1], \"b-o\", linewidth=3,\n         label=\"Batch\")\nplt.legend(loc=\"upper left\")\nplt.xlabel(r\"$\\theta_0$\")\nplt.ylabel(r\"$\\theta_1$   \", rotation=0)\nplt.axis([2.6, 4.6, 2.3, 3.4])\nplt.grid()\nsave_fig(\"gradient_descent_paths_plot\")\nplt.show()"
  },
  {
    "objectID": "about.html#ridge-regression",
    "href": "about.html#ridge-regression",
    "title": "Probability Theory and Random Variables",
    "section": "Ridge Regression",
    "text": "Ridge Regression\nLet’s generate a very small and noisy linear dataset:\n\n# extra code – we've done this type of generation several times before\nnp.random.seed(42)\nm = 20\nX = 3 * np.random.rand(m, 1)\ny = 1 + 0.5 * X + np.random.randn(m, 1) / 1.5\nX_new = np.linspace(0, 3, 100).reshape(100, 1)\n\n\n# extra code – a quick peek at the dataset we just generated\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \".\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$  \", rotation=0)\nplt.axis([0, 3, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import Ridge\n\nridge_reg = Ridge(alpha=0.1, solver=\"cholesky\")\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55325833]])\n\n\n\n# extra code – this cell generates and saves Figure 4–17\n\ndef plot_model(model_class, polynomial, alphas, **model_kwargs):\n    plt.plot(X, y, \"b.\", linewidth=3)\n    for alpha, style in zip(alphas, (\"b:\", \"g--\", \"r-\")):\n        if alpha &gt; 0:\n            model = model_class(alpha, **model_kwargs)\n        else:\n            model = LinearRegression()\n        if polynomial:\n            model = make_pipeline(\n                PolynomialFeatures(degree=10, include_bias=False),\n                StandardScaler(),\n                model)\n        model.fit(X, y)\n        y_new_regul = model.predict(X_new)\n        plt.plot(X_new, y_new_regul, style, linewidth=2,\n                 label=fr\"$\\alpha = {alpha}$\")\n    plt.legend(loc=\"upper left\")\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 3, 0, 3.5])\n    plt.grid()\n\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Ridge, polynomial=False, alphas=(0, 10, 100), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Ridge, polynomial=True, alphas=(0, 10**-5, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"ridge_regression_plot\")\nplt.show()\n\n\n\n\n\nsgd_reg = SGDRegressor(penalty=\"l2\", alpha=0.1 / m, tol=None,\n                       max_iter=1000, eta0=0.01, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\nsgd_reg.predict([[1.5]])\n\narray([1.55302613])\n\n\n\n# extra code – show that we get roughly the same solution as earlier when\n#              we use Stochastic Average GD (solver=\"sag\")\nridge_reg = Ridge(alpha=0.1, solver=\"sag\", random_state=42)\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55326019]])\n\n\n\n# extra code – shows the closed form solution of Ridge regression,\n#              compare with the next Ridge model's learned parameters below\nalpha = 0.1\nA = np.array([[0., 0.], [0., 1.]])\nX_b = np.c_[np.ones(m), X]\nnp.linalg.inv(X_b.T @ X_b + alpha * A) @ X_b.T @ y\n\narray([[0.97898394],\n       [0.3828496 ]])\n\n\n\nridge_reg.intercept_, ridge_reg.coef_  # extra code\n\n(array([0.97896386]), array([[0.38286422]]))"
  },
  {
    "objectID": "about.html#lasso-regression",
    "href": "about.html#lasso-regression",
    "title": "Probability Theory and Random Variables",
    "section": "Lasso Regression",
    "text": "Lasso Regression\n\nfrom sklearn.linear_model import Lasso\n\nlasso_reg = Lasso(alpha=0.1)\nlasso_reg.fit(X, y)\nlasso_reg.predict([[1.5]])\n\narray([1.53788174])\n\n\n\n# extra code – this cell generates and saves Figure 4–18\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Lasso, polynomial=False, alphas=(0, 0.1, 1), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Lasso, polynomial=True, alphas=(0, 1e-2, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"lasso_regression_plot\")\nplt.show()\n\n\n\n\n\n# extra code – this BIG cell generates and saves Figure 4–19\n\nt1a, t1b, t2a, t2b = -1, 3, -1.5, 1.5\n\nt1s = np.linspace(t1a, t1b, 500)\nt2s = np.linspace(t2a, t2b, 500)\nt1, t2 = np.meshgrid(t1s, t2s)\nT = np.c_[t1.ravel(), t2.ravel()]\nXr = np.array([[1, 1], [1, -1], [1, 0.5]])\nyr = 2 * Xr[:, :1] + 0.5 * Xr[:, 1:]\n\nJ = (1 / len(Xr) * ((T @ Xr.T - yr.T) ** 2).sum(axis=1)).reshape(t1.shape)\n\nN1 = np.linalg.norm(T, ord=1, axis=1).reshape(t1.shape)\nN2 = np.linalg.norm(T, ord=2, axis=1).reshape(t1.shape)\n\nt_min_idx = np.unravel_index(J.argmin(), J.shape)\nt1_min, t2_min = t1[t_min_idx], t2[t_min_idx]\n\nt_init = np.array([[0.25], [-1]])\n\ndef bgd_path(theta, X, y, l1, l2, core=1, eta=0.05, n_iterations=200):\n    path = [theta]\n    for iteration in range(n_iterations):\n        gradients = (core * 2 / len(X) * X.T @ (X @ theta - y)\n                     + l1 * np.sign(theta) + l2 * theta)\n        theta = theta - eta * gradients\n        path.append(theta)\n    return np.array(path)\n\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(10.1, 8))\n\nfor i, N, l1, l2, title in ((0, N1, 2.0, 0, \"Lasso\"), (1, N2, 0, 2.0, \"Ridge\")):\n    JR = J + l1 * N1 + l2 * 0.5 * N2 ** 2\n\n    tr_min_idx = np.unravel_index(JR.argmin(), JR.shape)\n    t1r_min, t2r_min = t1[tr_min_idx], t2[tr_min_idx]\n\n    levels = np.exp(np.linspace(0, 1, 20)) - 1\n    levelsJ = levels * (J.max() - J.min()) + J.min()\n    levelsJR = levels * (JR.max() - JR.min()) + JR.min()\n    levelsN = np.linspace(0, N.max(), 10)\n\n    path_J = bgd_path(t_init, Xr, yr, l1=0, l2=0)\n    path_JR = bgd_path(t_init, Xr, yr, l1, l2)\n    path_N = bgd_path(theta=np.array([[2.0], [0.5]]), X=Xr, y=yr,\n                      l1=np.sign(l1) / 3, l2=np.sign(l2), core=0)\n    ax = axes[i, 0]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, N / 2.0, levels=levelsN)\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.set_title(fr\"$\\ell_{i + 1}$ penalty\")\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n    ax.set_ylabel(r\"$\\theta_2$\", rotation=0)\n\n    ax = axes[i, 1]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, JR, levels=levelsJR, alpha=0.9)\n    ax.plot(path_JR[:, 0], path_JR[:, 1], \"w-o\")\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.plot(t1r_min, t2r_min, \"rs\")\n    ax.set_title(title)\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n\nsave_fig(\"lasso_vs_ridge_plot\")\nplt.show()"
  },
  {
    "objectID": "about.html#elastic-net",
    "href": "about.html#elastic-net",
    "title": "Probability Theory and Random Variables",
    "section": "Elastic Net",
    "text": "Elastic Net\n\nfrom sklearn.linear_model import ElasticNet\n\nelastic_net = ElasticNet(alpha=0.1, l1_ratio=0.5)\nelastic_net.fit(X, y)\nelastic_net.predict([[1.5]])\n\narray([1.54333232])"
  },
  {
    "objectID": "about.html#early-stopping",
    "href": "about.html#early-stopping",
    "title": "Probability Theory and Random Variables",
    "section": "Early Stopping",
    "text": "Early Stopping\nLet’s go back to the quadratic dataset we used earlier:\n\nfrom copy import deepcopy\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# extra code – creates the same quadratic dataset as earlier and splits it\nnp.random.seed(42)\nm = 100\nX = 6 * np.random.rand(m, 1) - 3\ny = 0.5 * X ** 2 + X + 2 + np.random.randn(m, 1)\nX_train, y_train = X[: m // 2], y[: m // 2, 0]\nX_valid, y_valid = X[m // 2 :], y[m // 2 :, 0]\n\npreprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False),\n                              StandardScaler())\nX_train_prep = preprocessing.fit_transform(X_train)\nX_valid_prep = preprocessing.transform(X_valid)\nsgd_reg = SGDRegressor(penalty=None, eta0=0.002, random_state=42)\nn_epochs = 500\nbest_valid_rmse = float('inf')\ntrain_errors, val_errors = [], []  # extra code – it's for the figure below\n\nfor epoch in range(n_epochs):\n    sgd_reg.partial_fit(X_train_prep, y_train)\n    y_valid_predict = sgd_reg.predict(X_valid_prep)\n    val_error = mean_squared_error(y_valid, y_valid_predict, squared=False)\n    if val_error &lt; best_valid_rmse:\n        best_valid_rmse = val_error\n        best_model = deepcopy(sgd_reg)\n\n    # extra code – we evaluate the train error and save it for the figure\n    y_train_predict = sgd_reg.predict(X_train_prep)\n    train_error = mean_squared_error(y_train, y_train_predict, squared=False)\n    val_errors.append(val_error)\n    train_errors.append(train_error)\n\n# extra code – this section generates and saves Figure 4–20\nbest_epoch = np.argmin(val_errors)\nplt.figure(figsize=(6, 4))\nplt.annotate('Best model',\n             xy=(best_epoch, best_valid_rmse),\n             xytext=(best_epoch, best_valid_rmse + 0.5),\n             ha=\"center\",\n             arrowprops=dict(facecolor='black', shrink=0.05))\nplt.plot([0, n_epochs], [best_valid_rmse, best_valid_rmse], \"k:\", linewidth=2)\nplt.plot(val_errors, \"b-\", linewidth=3, label=\"Validation set\")\nplt.plot(best_epoch, best_valid_rmse, \"bo\")\nplt.plot(train_errors, \"r--\", linewidth=2, label=\"Training set\")\nplt.legend(loc=\"upper right\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"RMSE\")\nplt.axis([0, n_epochs, 0, 3.5])\nplt.grid()\nsave_fig(\"early_stopping_plot\")\nplt.show()"
  },
  {
    "objectID": "about.html#estimating-probabilities",
    "href": "about.html#estimating-probabilities",
    "title": "Probability Theory and Random Variables",
    "section": "Estimating Probabilities",
    "text": "Estimating Probabilities\n\n# extra code – generates and saves Figure 4–21\n\nlim = 6\nt = np.linspace(-lim, lim, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.figure(figsize=(8, 3))\nplt.plot([-lim, lim], [0, 0], \"k-\")\nplt.plot([-lim, lim], [0.5, 0.5], \"k:\")\nplt.plot([-lim, lim], [1, 1], \"k:\")\nplt.plot([0, 0], [-1.1, 1.1], \"k-\")\nplt.plot(t, sig, \"b-\", linewidth=2, label=r\"$\\sigma(t) = \\dfrac{1}{1 + e^{-t}}$\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.axis([-lim, lim, -0.1, 1.1])\nplt.gca().set_yticks([0, 0.25, 0.5, 0.75, 1])\nplt.grid()\nsave_fig(\"logistic_function_plot\")\nplt.show()"
  },
  {
    "objectID": "about.html#decision-boundaries",
    "href": "about.html#decision-boundaries",
    "title": "Probability Theory and Random Variables",
    "section": "Decision Boundaries",
    "text": "Decision Boundaries\n\nfrom sklearn.datasets import load_iris\n\niris = load_iris(as_frame=True)\nlist(iris)\n\n['data',\n 'target',\n 'frame',\n 'target_names',\n 'DESCR',\n 'feature_names',\n 'filename',\n 'data_module']\n\n\n\nprint(iris.DESCR)  # extra code – it's a bit too long\n\n.. _iris_dataset:\n\nIris plants dataset\n--------------------\n\n**Data Set Characteristics:**\n\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n                \n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThe famous Iris database, first used by Sir R.A. Fisher. The dataset is taken\nfrom Fisher's paper. Note that it's the same as in R, but not as in the UCI\nMachine Learning Repository, which has two wrong data points.\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher's paper is a classic in the field and\nis referenced frequently to this day.  (See Duda & Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\n|details-start|\n**References**\n|details-split|\n\n- Fisher, R.A. \"The use of multiple measurements in taxonomic problems\"\n  Annual Eugenics, 7, Part II, 179-188 (1936); also in \"Contributions to\n  Mathematical Statistics\" (John Wiley, NY, 1950).\n- Duda, R.O., & Hart, P.E. (1973) Pattern Classification and Scene Analysis.\n  (Q327.D83) John Wiley & Sons.  ISBN 0-471-22361-1.  See page 218.\n- Dasarathy, B.V. (1980) \"Nosing Around the Neighborhood: A New System\n  Structure and Classification Rule for Recognition in Partially Exposed\n  Environments\".  IEEE Transactions on Pattern Analysis and Machine\n  Intelligence, Vol. PAMI-2, No. 1, 67-71.\n- Gates, G.W. (1972) \"The Reduced Nearest Neighbor Rule\".  IEEE Transactions\n  on Information Theory, May 1972, 431-433.\n- See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al\"s AUTOCLASS II\n  conceptual clustering system finds 3 classes in the data.\n- Many, many more ...\n\n|details-end|\n\n\n\niris.data.head(3)\n\n\n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n\n\n\n\n\n\niris.target.head(3)  # note that the instances are not shuffled\n\n0    0\n1    0\n2    0\nName: target, dtype: int64\n\n\n\niris.target_names\n\narray(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')\n\n\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\n\nX = iris.data[[\"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(random_state=42)\nlog_reg.fit(X_train, y_train)\n\nLogisticRegression(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=42)\n\n\n\nX_new = np.linspace(0, 3, 1000).reshape(-1, 1)  # reshape to get a column vector\ny_proba = log_reg.predict_proba(X_new)\ndecision_boundary = X_new[y_proba[:, 1] &gt;= 0.5][0, 0]\n\nplt.figure(figsize=(8, 3))  # extra code – not needed, just formatting\nplt.plot(X_new, y_proba[:, 0], \"b--\", linewidth=2,\n         label=\"Not Iris virginica proba\")\nplt.plot(X_new, y_proba[:, 1], \"g-\", linewidth=2, label=\"Iris virginica proba\")\nplt.plot([decision_boundary, decision_boundary], [0, 1], \"k:\", linewidth=2,\n         label=\"Decision boundary\")\n\n# extra code – this section beautifies and saves Figure 4–23\nplt.arrow(x=decision_boundary, y=0.08, dx=-0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"b\", ec=\"b\")\nplt.arrow(x=decision_boundary, y=0.92, dx=0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"g\", ec=\"g\")\nplt.plot(X_train[y_train == 0], y_train[y_train == 0], \"bs\")\nplt.plot(X_train[y_train == 1], y_train[y_train == 1], \"g^\")\nplt.xlabel(\"Petal width (cm)\")\nplt.ylabel(\"Probability\")\nplt.legend(loc=\"center left\")\nplt.axis([0, 3, -0.02, 1.02])\nplt.grid()\nsave_fig(\"logistic_regression_plot\")\n\nplt.show()\n\n\n\n\n\ndecision_boundary\n\n1.6516516516516517\n\n\n\nlog_reg.predict([[1.7], [1.5]])\n\narray([ True, False])\n\n\n\n# extra code – this cell generates and saves Figure 4–24\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(C=2, random_state=42)\nlog_reg.fit(X_train, y_train)\n\n# for the contour plot\nx0, x1 = np.meshgrid(np.linspace(2.9, 7, 500).reshape(-1, 1),\n                     np.linspace(0.8, 2.7, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]  # one instance per point on the figure\ny_proba = log_reg.predict_proba(X_new)\nzz = y_proba[:, 1].reshape(x0.shape)\n\n# for the decision boundary\nleft_right = np.array([2.9, 7])\nboundary = -((log_reg.coef_[0, 0] * left_right + log_reg.intercept_[0])\n             / log_reg.coef_[0, 1])\n\nplt.figure(figsize=(10, 4))\nplt.plot(X_train[y_train == 0, 0], X_train[y_train == 0, 1], \"bs\")\nplt.plot(X_train[y_train == 1, 0], X_train[y_train == 1, 1], \"g^\")\ncontour = plt.contour(x0, x1, zz, cmap=plt.cm.brg)\nplt.clabel(contour, inline=1)\nplt.plot(left_right, boundary, \"k--\", linewidth=3)\nplt.text(3.5, 1.27, \"Not Iris virginica\", color=\"b\", ha=\"center\")\nplt.text(6.5, 2.3, \"Iris virginica\", color=\"g\", ha=\"center\")\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.axis([2.9, 7, 0.8, 2.7])\nplt.grid()\nsave_fig(\"logistic_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "about.html#softmax-regression",
    "href": "about.html#softmax-regression",
    "title": "Probability Theory and Random Variables",
    "section": "Softmax Regression",
    "text": "Softmax Regression\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nsoftmax_reg = LogisticRegression(C=30, random_state=42)\nsoftmax_reg.fit(X_train, y_train)\n\nLogisticRegression(C=30, random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(C=30, random_state=42)\n\n\n\nsoftmax_reg.predict([[5, 2]])\n\narray([2])\n\n\n\nsoftmax_reg.predict_proba([[5, 2]]).round(2)\n\narray([[0.  , 0.04, 0.96]])\n\n\n\n# extra code – this cell generates and saves Figure 4–25\n\nfrom matplotlib.colors import ListedColormap\n\ncustom_cmap = ListedColormap([\"#fafab0\", \"#9898ff\", \"#a0faa0\"])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\n\ny_proba = softmax_reg.predict_proba(X_new)\ny_predict = softmax_reg.predict(X_new)\n\nzz1 = y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"center left\")\nplt.axis([0.5, 7, 0, 3.5])\nplt.grid()\nsave_fig(\"softmax_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "about.html#to-11.",
    "href": "about.html#to-11.",
    "title": "Probability Theory and Random Variables",
    "section": "1. to 11.",
    "text": "1. to 11.\n\nIf you have a training set with millions of features you can use Stochastic Gradient Descent or Mini-batch Gradient Descent, and perhaps Batch Gradient Descent if the training set fits in memory. But you cannot use the Normal Equation or the SVD approach because the computational complexity grows quickly (more than quadratically) with the number of features.\nIf the features in your training set have very different scales, the cost function will have the shape of an elongated bowl, so the Gradient Descent algorithms will take a long time to converge. To solve this you should scale the data before training the model. Note that the Normal Equation or SVD approach will work just fine without scaling. Moreover, regularized models may converge to a suboptimal solution if the features are not scaled: since regularization penalizes large weights, features with smaller values will tend to be ignored compared to features with larger values.\nGradient Descent cannot get stuck in a local minimum when training a Logistic Regression model because the cost function is convex. Convex means that if you draw a straight line between any two points on the curve, the line never crosses the curve.\nIf the optimization problem is convex (such as Linear Regression or Logistic Regression), and assuming the learning rate is not too high, then all Gradient Descent algorithms will approach the global optimum and end up producing fairly similar models. However, unless you gradually reduce the learning rate, Stochastic GD and Mini-batch GD will never truly converge; instead, they will keep jumping back and forth around the global optimum. This means that even if you let them run for a very long time, these Gradient Descent algorithms will produce slightly different models.\nIf the validation error consistently goes up after every epoch, then one possibility is that the learning rate is too high and the algorithm is diverging. If the training error also goes up, then this is clearly the problem and you should reduce the learning rate. However, if the training error is not going up, then your model is overfitting the training set and you should stop training.\nDue to their random nature, neither Stochastic Gradient Descent nor Mini-batch Gradient Descent is guaranteed to make progress at every single training iteration. So if you immediately stop training when the validation error goes up, you may stop much too early, before the optimum is reached. A better option is to save the model at regular intervals; then, when it has not improved for a long time (meaning it will probably never beat the record), you can revert to the best saved model.\nStochastic Gradient Descent has the fastest training iteration since it considers only one training instance at a time, so it is generally the first to reach the vicinity of the global optimum (or Mini-batch GD with a very small mini-batch size). However, only Batch Gradient Descent will actually converge, given enough training time. As mentioned, Stochastic GD and Mini-batch GD will bounce around the optimum, unless you gradually reduce the learning rate.\nIf the validation error is much higher than the training error, this is likely because your model is overfitting the training set. One way to try to fix this is to reduce the polynomial degree: a model with fewer degrees of freedom is less likely to overfit. Another thing you can try is to regularize the model—for example, by adding an ℓ₂ penalty (Ridge) or an ℓ₁ penalty (Lasso) to the cost function. This will also reduce the degrees of freedom of the model. Lastly, you can try to increase the size of the training set.\nIf both the training error and the validation error are almost equal and fairly high, the model is likely underfitting the training set, which means it has a high bias. You should try reducing the regularization hyperparameter α.\nLet’s see:\n\n\nA model with some regularization typically performs better than a model without any regularization, so you should generally prefer Ridge Regression over plain Linear Regression.\nLasso Regression uses an ℓ₁ penalty, which tends to push the weights down to exactly zero. This leads to sparse models, where all weights are zero except for the most important weights. This is a way to perform feature selection automatically, which is good if you suspect that only a few features actually matter. When you are not sure, you should prefer Ridge Regression.\nElastic Net is generally preferred over Lasso since Lasso may behave erratically in some cases (when several features are strongly correlated or when there are more features than training instances). However, it does add an extra hyperparameter to tune. If you want Lasso without the erratic behavior, you can just use Elastic Net with an l1_ratio close to 1.\n\n\nIf you want to classify pictures as outdoor/indoor and daytime/nighttime, since these are not exclusive classes (i.e., all four combinations are possible) you should train two Logistic Regression classifiers."
  },
  {
    "objectID": "about.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "href": "about.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "title": "Probability Theory and Random Variables",
    "section": "12. Batch Gradient Descent with early stopping for Softmax Regression",
    "text": "12. Batch Gradient Descent with early stopping for Softmax Regression\nExercise: Implement Batch Gradient Descent with early stopping for Softmax Regression without using Scikit-Learn, only NumPy. Use it on a classification task such as the iris dataset.\nLet’s start by loading the data. We will just reuse the Iris dataset we loaded earlier.\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"].values\n\nWe need to add the bias term for every instance (\\(x_0 = 1\\)). The easiest option to do this would be to use Scikit-Learn’s add_dummy_feature() function, but the point of this exercise is to get a better understanding of the algorithms by implementing them manually. So here is one possible implementation:\n\nX_with_bias = np.c_[np.ones(len(X)), X]\n\nThe easiest option to split the dataset into a training set, a validation set and a test set would be to use Scikit-Learn’s train_test_split() function, but again, we want to do it manually:\n\ntest_ratio = 0.2\nvalidation_ratio = 0.2\ntotal_size = len(X_with_bias)\n\ntest_size = int(total_size * test_ratio)\nvalidation_size = int(total_size * validation_ratio)\ntrain_size = total_size - test_size - validation_size\n\nnp.random.seed(42)\nrnd_indices = np.random.permutation(total_size)\n\nX_train = X_with_bias[rnd_indices[:train_size]]\ny_train = y[rnd_indices[:train_size]]\nX_valid = X_with_bias[rnd_indices[train_size:-test_size]]\ny_valid = y[rnd_indices[train_size:-test_size]]\nX_test = X_with_bias[rnd_indices[-test_size:]]\ny_test = y[rnd_indices[-test_size:]]\n\nThe targets are currently class indices (0, 1 or 2), but we need target class probabilities to train the Softmax Regression model. Each instance will have target class probabilities equal to 0.0 for all classes except for the target class which will have a probability of 1.0 (in other words, the vector of class probabilities for any given instance is a one-hot vector). Let’s write a small function to convert the vector of class indices into a matrix containing a one-hot vector for each instance. To understand this code, you need to know that np.diag(np.ones(n)) creates an n×n matrix full of 0s except for 1s on the main diagonal. Moreover, if a is a NumPy array, then a[[1, 3, 2]] returns an array with 3 rows equal to a[1], a[3] and a[2] (this is advanced NumPy indexing).\n\ndef to_one_hot(y):\n    return np.diag(np.ones(y.max() + 1))[y]\n\nLet’s test this function on the first 10 instances:\n\ny_train[:10]\n\narray([1, 0, 2, 1, 1, 0, 1, 2, 1, 1])\n\n\n\nto_one_hot(y_train[:10])\n\narray([[0., 1., 0.],\n       [1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.],\n       [1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.]])\n\n\nLooks good, so let’s create the target class probabilities matrix for the training set and the test set:\n\nY_train_one_hot = to_one_hot(y_train)\nY_valid_one_hot = to_one_hot(y_valid)\nY_test_one_hot = to_one_hot(y_test)\n\nNow let’s scale the inputs. We compute the mean and standard deviation of each feature on the training set (except for the bias feature), then we center and scale each feature in the training set, the validation set, and the test set:\n\nmean = X_train[:, 1:].mean(axis=0)\nstd = X_train[:, 1:].std(axis=0)\nX_train[:, 1:] = (X_train[:, 1:] - mean) / std\nX_valid[:, 1:] = (X_valid[:, 1:] - mean) / std\nX_test[:, 1:] = (X_test[:, 1:] - mean) / std\n\nNow let’s implement the Softmax function. Recall that it is defined by the following equation:\n\\(\\sigma\\left(\\mathbf{s}(\\mathbf{x})\\right)_k = \\dfrac{\\exp\\left(s_k(\\mathbf{x})\\right)}{\\sum\\limits_{j=1}^{K}{\\exp\\left(s_j(\\mathbf{x})\\right)}}\\)\n\ndef softmax(logits):\n    exps = np.exp(logits)\n    exp_sums = exps.sum(axis=1, keepdims=True)\n    return exps / exp_sums\n\nWe are almost ready to start training. Let’s define the number of inputs and outputs:\n\nn_inputs = X_train.shape[1]  # == 3 (2 features plus the bias term)\nn_outputs = len(np.unique(y_train))  # == 3 (there are 3 iris classes)\n\nNow here comes the hardest part: training! Theoretically, it’s simple: it’s just a matter of translating the math equations into Python code. But in practice, it can be quite tricky: in particular, it’s easy to mix up the order of the terms, or the indices. You can even end up with code that looks like it’s working but is actually not computing exactly the right thing. When unsure, you should write down the shape of each term in the equation and make sure the corresponding terms in your code match closely. It can also help to evaluate each term independently and print them out. The good news it that you won’t have to do this everyday, since all this is well implemented by Scikit-Learn, but it will help you understand what’s going on under the hood.\nSo the equations we will need are the cost function:\n\\(J(\\mathbf{\\Theta}) = - \\dfrac{1}{m}\\sum\\limits_{i=1}^{m}\\sum\\limits_{k=1}^{K}{y_k^{(i)}\\log\\left(\\hat{p}_k^{(i)}\\right)}\\)\nAnd the equation for the gradients:\n\\(\\nabla_{\\mathbf{\\theta}^{(k)}} \\, J(\\mathbf{\\Theta}) = \\dfrac{1}{m} \\sum\\limits_{i=1}^{m}{ \\left ( \\hat{p}^{(i)}_k - y_k^{(i)} \\right ) \\mathbf{x}^{(i)}}\\)\nNote that \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) may not be computable if \\(\\hat{p}_k^{(i)} = 0\\). So we will add a tiny value \\(\\epsilon\\) to \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) to avoid getting nan values.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        print(epoch, xentropy_losses.sum(axis=1).mean())\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    Theta = Theta - eta * gradients\n\n0 3.7085808486476917\n1000 0.14519367480830647\n2000 0.13013095755040877\n3000 0.12009639326384532\n4000 0.11372961364786878\n5000 0.11002459532472424\n\n\nAnd that’s it! The Softmax model is trained. Let’s look at the model parameters:\n\nTheta\n\narray([[ 0.41931626,  6.11112089, -5.52429876],\n       [-6.53054533, -0.74608616,  8.33137102],\n       [-5.28115784,  0.25152675,  6.90680425]])\n\n\nLet’s make predictions for the validation set and check the accuracy score:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nWell, this model looks pretty ok. For the sake of the exercise, let’s add a bit of \\(\\ell_2\\) regularization. The following training code is similar to the one above, but the loss now has an additional \\(\\ell_2\\) penalty, and the gradients have the proper additional term (note that we don’t regularize the first element of Theta since this corresponds to the bias term). Also, let’s try increasing the learning rate eta.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\nalpha = 0.01  # regularization hyperparameter\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n        total_loss = xentropy_losses.sum(axis=1).mean() + alpha * l2_loss\n        print(epoch, total_loss.round(4))\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n1000 0.3259\n2000 0.3259\n3000 0.3259\n4000 0.3259\n5000 0.3259\n\n\nBecause of the additional \\(\\ell_2\\) penalty, the loss seems greater than earlier, but perhaps this model will perform better? Let’s find out:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nIn this case, the \\(\\ell_2\\) penalty did not change the test accuracy. Perhaps try fine-tuning alpha?\nNow let’s add early stopping. For this we just need to measure the loss on the validation set at every iteration and stop when the error starts growing.\n\neta = 0.5\nn_epochs = 50_001\nm = len(X_train)\nepsilon = 1e-5\nC = 100  # regularization hyperparameter\nbest_loss = np.infty\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    Y_proba_valid = softmax(X_valid @ Theta)\n    xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n    l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n    total_loss = xentropy_losses.sum(axis=1).mean() + 1 / C * l2_loss\n    if epoch % 1000 == 0:\n        print(epoch, total_loss.round(4))\n    if total_loss &lt; best_loss:\n        best_loss = total_loss\n    else:\n        print(epoch - 1, best_loss.round(4))\n        print(epoch, total_loss.round(4), \"early stopping!\")\n        break\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), 1 / C * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n281 0.3256\n282 0.3256 early stopping!\n\n\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nOh well, still no change in validation accuracy, but at least early stopping shortened training a bit.\nNow let’s plot the model’s predictions on the whole dataset (remember to scale all features fed to the model):\n\ncustom_cmap = mpl.colors.ListedColormap(['#fafab0', '#9898ff', '#a0faa0'])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\nX_new = (X_new - mean) / std\nX_new_with_bias = np.c_[np.ones(len(X_new)), X_new]\n\nlogits = X_new_with_bias @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\nzz1 = Y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"upper left\")\nplt.axis([0, 7, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\nAnd now let’s measure the final model’s accuracy on the test set:\n\nlogits = X_test @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_test).mean()\naccuracy_score\n\n0.9666666666666667\n\n\nWell we get even better performance on the test set. This variability is likely due to the very small size of the dataset: depending on how you sample the training set, validation set and the test set, you can get quite different results. Try changing the random seed and running the code again a few times, you will see that the results will vary."
  },
  {
    "objectID": "blog3.html",
    "href": "blog3.html",
    "title": "Linear and Non-Linear Regression",
    "section": "",
    "text": "Chapter 4 – Training Models\nThis notebook contains all the sample code and solutions to the exercises in chapter 4.\nThis project requires Python 3.7 or above:\nimport sys\n\nassert sys.version_info &gt;= (3, 7)\nIt also requires Scikit-Learn ≥ 1.0.1:\nfrom packaging import version\nimport sklearn\n\nassert version.parse(sklearn.__version__) &gt;= version.parse(\"1.0.1\")\nAs we did in previous chapters, let’s define the default font sizes to make the figures prettier:\nimport matplotlib.pyplot as plt\n\nplt.rc('font', size=14)\nplt.rc('axes', labelsize=14, titlesize=14)\nplt.rc('legend', fontsize=14)\nplt.rc('xtick', labelsize=10)\nplt.rc('ytick', labelsize=10)\nAnd let’s create the images/training_linear_models folder (if it doesn’t already exist), and define the save_fig() function which is used through this notebook to save the figures in high-res for the book:\nfrom pathlib import Path\n\nIMAGES_PATH = Path() / \"images\" / \"training_linear_models\"\nIMAGES_PATH.mkdir(parents=True, exist_ok=True)\n\ndef save_fig(fig_id, tight_layout=True, fig_extension=\"png\", resolution=300):\n    path = IMAGES_PATH / f\"{fig_id}.{fig_extension}\"\n    if tight_layout:\n        plt.tight_layout()\n    plt.savefig(path, format=fig_extension, dpi=resolution)"
  },
  {
    "objectID": "blog3.html#the-normal-equation",
    "href": "blog3.html#the-normal-equation",
    "title": "Linear and Non-Linear Regression",
    "section": "The Normal Equation",
    "text": "The Normal Equation\n\nimport numpy as np\n\nnp.random.seed(42)  # to make this code example reproducible\nm = 100  # number of instances\nX = 2 * np.random.rand(m, 1)  # column vector\ny = 4 + 3 * X + np.random.randn(m, 1)  # column vector\n\n\n# extra code – generates and saves Figure 4–1\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"generated_data_plot\")\nplt.show()\n\n\n\n\n\nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)  # add x0 = 1 to each instance\ntheta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n\n\ntheta_best\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\nX_new = np.array([[0], [2]])\nX_new_b = add_dummy_feature(X_new)  # add x0 = 1 to each instance\ny_predict = X_new_b @ theta_best\ny_predict\n\narray([[4.21509616],\n       [9.75532293]])\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\nplt.plot(X_new, y_predict, \"r-\", label=\"Predictions\")\nplt.plot(X, y, \"b.\")\n\n# extra code – beautifies and saves Figure 4–2\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nplt.legend(loc=\"upper left\")\nsave_fig(\"linear_model_predictions_plot\")\n\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\n\nlin_reg = LinearRegression()\nlin_reg.fit(X, y)\nlin_reg.intercept_, lin_reg.coef_\n\n(array([4.21509616]), array([[2.77011339]]))\n\n\n\nlin_reg.predict(X_new)\n\narray([[4.21509616],\n       [9.75532293]])\n\n\nThe LinearRegression class is based on the scipy.linalg.lstsq() function (the name stands for “least squares”), which you could call directly:\n\ntheta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=1e-6)\ntheta_best_svd\n\narray([[4.21509616],\n       [2.77011339]])\n\n\nThis function computes \\(\\mathbf{X}^+\\mathbf{y}\\), where \\(\\mathbf{X}^{+}\\) is the pseudoinverse of \\(\\mathbf{X}\\) (specifically the Moore-Penrose inverse). You can use np.linalg.pinv() to compute the pseudoinverse directly:\n\nnp.linalg.pinv(X_b) @ y\n\narray([[4.21509616],\n       [2.77011339]])"
  },
  {
    "objectID": "blog3.html#batch-gradient-descent",
    "href": "blog3.html#batch-gradient-descent",
    "title": "Linear and Non-Linear Regression",
    "section": "Batch Gradient Descent",
    "text": "Batch Gradient Descent\n\neta = 0.1  # learning rate\nn_epochs = 1000\nm = len(X_b)  # number of instances\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # randomly initialized model parameters\n\nfor epoch in range(n_epochs):\n    gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n    theta = theta - eta * gradients\n\nThe trained model parameters:\n\ntheta\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\n# extra code – generates and saves Figure 4–8\n\nimport matplotlib as mpl\n\ndef plot_gradient_descent(theta, eta):\n    m = len(X_b)\n    plt.plot(X, y, \"b.\")\n    n_epochs = 1000\n    n_shown = 20\n    theta_path = []\n    for epoch in range(n_epochs):\n        if epoch &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(epoch / n_shown + 0.15))\n            plt.plot(X_new, y_predict, linestyle=\"solid\", color=color)\n        gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n        theta = theta - eta * gradients\n        theta_path.append(theta)\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 2, 0, 15])\n    plt.grid()\n    plt.title(fr\"$\\eta = {eta}$\")\n    return theta_path\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nplt.figure(figsize=(10, 4))\nplt.subplot(131)\nplot_gradient_descent(theta, eta=0.02)\nplt.ylabel(\"$y$\", rotation=0)\nplt.subplot(132)\ntheta_path_bgd = plot_gradient_descent(theta, eta=0.1)\nplt.gca().axes.yaxis.set_ticklabels([])\nplt.subplot(133)\nplt.gca().axes.yaxis.set_ticklabels([])\nplot_gradient_descent(theta, eta=0.5)\nsave_fig(\"gradient_descent_plot\")\nplt.show()"
  },
  {
    "objectID": "blog3.html#stochastic-gradient-descent",
    "href": "blog3.html#stochastic-gradient-descent",
    "title": "Linear and Non-Linear Regression",
    "section": "Stochastic Gradient Descent",
    "text": "Stochastic Gradient Descent\n\ntheta_path_sgd = []  # extra code – we need to store the path of theta in the\n                     #              parameter space to plot the next figure\n\n\nn_epochs = 50\nt0, t1 = 5, 50  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nn_shown = 20  # extra code – just needed to generate the figure below\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\n\nfor epoch in range(n_epochs):\n    for iteration in range(m):\n\n        # extra code – these 4 lines are used to generate the figure\n        if epoch == 0 and iteration &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(iteration / n_shown + 0.15))\n            plt.plot(X_new, y_predict, color=color)\n\n        random_index = np.random.randint(m)\n        xi = X_b[random_index : random_index + 1]\n        yi = y[random_index : random_index + 1]\n        gradients = 2 * xi.T @ (xi @ theta - yi)  # for SGD, do not divide by m\n        eta = learning_schedule(epoch * m + iteration)\n        theta = theta - eta * gradients\n        theta_path_sgd.append(theta)  # extra code – to generate the figure\n\n# extra code – this section beautifies and saves Figure 4–10\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"sgd_plot\")\nplt.show()\n\n\n\n\n\ntheta\n\narray([[4.21076011],\n       [2.74856079]])\n\n\n\nfrom sklearn.linear_model import SGDRegressor\n\nsgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, penalty=None, eta0=0.01,\n                       n_iter_no_change=100, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\n\nSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SGDRegressorSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)\n\n\n\nsgd_reg.intercept_, sgd_reg.coef_\n\n(array([4.21278812]), array([2.77270267]))"
  },
  {
    "objectID": "blog3.html#mini-batch-gradient-descent",
    "href": "blog3.html#mini-batch-gradient-descent",
    "title": "Linear and Non-Linear Regression",
    "section": "Mini-batch gradient descent",
    "text": "Mini-batch gradient descent\nThe code in this section is used to generate the next figure, it is not in the book.\n\n# extra code – this cell generates and saves Figure 4–11\n\nfrom math import ceil\n\nn_epochs = 50\nminibatch_size = 20\nn_batches_per_epoch = ceil(m / minibatch_size)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nt0, t1 = 200, 1000  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\ntheta_path_mgd = []\nfor epoch in range(n_epochs):\n    shuffled_indices = np.random.permutation(m)\n    X_b_shuffled = X_b[shuffled_indices]\n    y_shuffled = y[shuffled_indices]\n    for iteration in range(0, n_batches_per_epoch):\n        idx = iteration * minibatch_size\n        xi = X_b_shuffled[idx : idx + minibatch_size]\n        yi = y_shuffled[idx : idx + minibatch_size]\n        gradients = 2 / minibatch_size * xi.T @ (xi @ theta - yi)\n        eta = learning_schedule(iteration)\n        theta = theta - eta * gradients\n        theta_path_mgd.append(theta)\n\ntheta_path_bgd = np.array(theta_path_bgd)\ntheta_path_sgd = np.array(theta_path_sgd)\ntheta_path_mgd = np.array(theta_path_mgd)\n\nplt.figure(figsize=(7, 4))\nplt.plot(theta_path_sgd[:, 0], theta_path_sgd[:, 1], \"r-s\", linewidth=1,\n         label=\"Stochastic\")\nplt.plot(theta_path_mgd[:, 0], theta_path_mgd[:, 1], \"g-+\", linewidth=2,\n         label=\"Mini-batch\")\nplt.plot(theta_path_bgd[:, 0], theta_path_bgd[:, 1], \"b-o\", linewidth=3,\n         label=\"Batch\")\nplt.legend(loc=\"upper left\")\nplt.xlabel(r\"$\\theta_0$\")\nplt.ylabel(r\"$\\theta_1$   \", rotation=0)\nplt.axis([2.6, 4.6, 2.3, 3.4])\nplt.grid()\nsave_fig(\"gradient_descent_paths_plot\")\nplt.show()"
  },
  {
    "objectID": "blog3.html#ridge-regression",
    "href": "blog3.html#ridge-regression",
    "title": "Linear and Non-Linear Regression",
    "section": "Ridge Regression",
    "text": "Ridge Regression\nLet’s generate a very small and noisy linear dataset:\n\n# extra code – we've done this type of generation several times before\nnp.random.seed(42)\nm = 20\nX = 3 * np.random.rand(m, 1)\ny = 1 + 0.5 * X + np.random.randn(m, 1) / 1.5\nX_new = np.linspace(0, 3, 100).reshape(100, 1)\n\n\n# extra code – a quick peek at the dataset we just generated\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \".\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$  \", rotation=0)\nplt.axis([0, 3, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import Ridge\n\nridge_reg = Ridge(alpha=0.1, solver=\"cholesky\")\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55325833]])\n\n\n\n# extra code – this cell generates and saves Figure 4–17\n\ndef plot_model(model_class, polynomial, alphas, **model_kwargs):\n    plt.plot(X, y, \"b.\", linewidth=3)\n    for alpha, style in zip(alphas, (\"b:\", \"g--\", \"r-\")):\n        if alpha &gt; 0:\n            model = model_class(alpha, **model_kwargs)\n        else:\n            model = LinearRegression()\n        if polynomial:\n            model = make_pipeline(\n                PolynomialFeatures(degree=10, include_bias=False),\n                StandardScaler(),\n                model)\n        model.fit(X, y)\n        y_new_regul = model.predict(X_new)\n        plt.plot(X_new, y_new_regul, style, linewidth=2,\n                 label=fr\"$\\alpha = {alpha}$\")\n    plt.legend(loc=\"upper left\")\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 3, 0, 3.5])\n    plt.grid()\n\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Ridge, polynomial=False, alphas=(0, 10, 100), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Ridge, polynomial=True, alphas=(0, 10**-5, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"ridge_regression_plot\")\nplt.show()\n\n\n\n\n\nsgd_reg = SGDRegressor(penalty=\"l2\", alpha=0.1 / m, tol=None,\n                       max_iter=1000, eta0=0.01, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\nsgd_reg.predict([[1.5]])\n\narray([1.55302613])\n\n\n\n# extra code – show that we get roughly the same solution as earlier when\n#              we use Stochastic Average GD (solver=\"sag\")\nridge_reg = Ridge(alpha=0.1, solver=\"sag\", random_state=42)\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55326019]])\n\n\n\n# extra code – shows the closed form solution of Ridge regression,\n#              compare with the next Ridge model's learned parameters below\nalpha = 0.1\nA = np.array([[0., 0.], [0., 1.]])\nX_b = np.c_[np.ones(m), X]\nnp.linalg.inv(X_b.T @ X_b + alpha * A) @ X_b.T @ y\n\narray([[0.97898394],\n       [0.3828496 ]])\n\n\n\nridge_reg.intercept_, ridge_reg.coef_  # extra code\n\n(array([0.97896386]), array([[0.38286422]]))"
  },
  {
    "objectID": "blog3.html#lasso-regression",
    "href": "blog3.html#lasso-regression",
    "title": "Linear and Non-Linear Regression",
    "section": "Lasso Regression",
    "text": "Lasso Regression\n\nfrom sklearn.linear_model import Lasso\n\nlasso_reg = Lasso(alpha=0.1)\nlasso_reg.fit(X, y)\nlasso_reg.predict([[1.5]])\n\narray([1.53788174])\n\n\n\n# extra code – this cell generates and saves Figure 4–18\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Lasso, polynomial=False, alphas=(0, 0.1, 1), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Lasso, polynomial=True, alphas=(0, 1e-2, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"lasso_regression_plot\")\nplt.show()\n\n\n\n\n\n# extra code – this BIG cell generates and saves Figure 4–19\n\nt1a, t1b, t2a, t2b = -1, 3, -1.5, 1.5\n\nt1s = np.linspace(t1a, t1b, 500)\nt2s = np.linspace(t2a, t2b, 500)\nt1, t2 = np.meshgrid(t1s, t2s)\nT = np.c_[t1.ravel(), t2.ravel()]\nXr = np.array([[1, 1], [1, -1], [1, 0.5]])\nyr = 2 * Xr[:, :1] + 0.5 * Xr[:, 1:]\n\nJ = (1 / len(Xr) * ((T @ Xr.T - yr.T) ** 2).sum(axis=1)).reshape(t1.shape)\n\nN1 = np.linalg.norm(T, ord=1, axis=1).reshape(t1.shape)\nN2 = np.linalg.norm(T, ord=2, axis=1).reshape(t1.shape)\n\nt_min_idx = np.unravel_index(J.argmin(), J.shape)\nt1_min, t2_min = t1[t_min_idx], t2[t_min_idx]\n\nt_init = np.array([[0.25], [-1]])\n\ndef bgd_path(theta, X, y, l1, l2, core=1, eta=0.05, n_iterations=200):\n    path = [theta]\n    for iteration in range(n_iterations):\n        gradients = (core * 2 / len(X) * X.T @ (X @ theta - y)\n                     + l1 * np.sign(theta) + l2 * theta)\n        theta = theta - eta * gradients\n        path.append(theta)\n    return np.array(path)\n\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(10.1, 8))\n\nfor i, N, l1, l2, title in ((0, N1, 2.0, 0, \"Lasso\"), (1, N2, 0, 2.0, \"Ridge\")):\n    JR = J + l1 * N1 + l2 * 0.5 * N2 ** 2\n\n    tr_min_idx = np.unravel_index(JR.argmin(), JR.shape)\n    t1r_min, t2r_min = t1[tr_min_idx], t2[tr_min_idx]\n\n    levels = np.exp(np.linspace(0, 1, 20)) - 1\n    levelsJ = levels * (J.max() - J.min()) + J.min()\n    levelsJR = levels * (JR.max() - JR.min()) + JR.min()\n    levelsN = np.linspace(0, N.max(), 10)\n\n    path_J = bgd_path(t_init, Xr, yr, l1=0, l2=0)\n    path_JR = bgd_path(t_init, Xr, yr, l1, l2)\n    path_N = bgd_path(theta=np.array([[2.0], [0.5]]), X=Xr, y=yr,\n                      l1=np.sign(l1) / 3, l2=np.sign(l2), core=0)\n    ax = axes[i, 0]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, N / 2.0, levels=levelsN)\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.set_title(fr\"$\\ell_{i + 1}$ penalty\")\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n    ax.set_ylabel(r\"$\\theta_2$\", rotation=0)\n\n    ax = axes[i, 1]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, JR, levels=levelsJR, alpha=0.9)\n    ax.plot(path_JR[:, 0], path_JR[:, 1], \"w-o\")\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.plot(t1r_min, t2r_min, \"rs\")\n    ax.set_title(title)\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n\nsave_fig(\"lasso_vs_ridge_plot\")\nplt.show()"
  },
  {
    "objectID": "blog3.html#elastic-net",
    "href": "blog3.html#elastic-net",
    "title": "Linear and Non-Linear Regression",
    "section": "Elastic Net",
    "text": "Elastic Net\n\nfrom sklearn.linear_model import ElasticNet\n\nelastic_net = ElasticNet(alpha=0.1, l1_ratio=0.5)\nelastic_net.fit(X, y)\nelastic_net.predict([[1.5]])\n\narray([1.54333232])"
  },
  {
    "objectID": "blog3.html#early-stopping",
    "href": "blog3.html#early-stopping",
    "title": "Linear and Non-Linear Regression",
    "section": "Early Stopping",
    "text": "Early Stopping\nLet’s go back to the quadratic dataset we used earlier:\n\nfrom copy import deepcopy\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# extra code – creates the same quadratic dataset as earlier and splits it\nnp.random.seed(42)\nm = 100\nX = 6 * np.random.rand(m, 1) - 3\ny = 0.5 * X ** 2 + X + 2 + np.random.randn(m, 1)\nX_train, y_train = X[: m // 2], y[: m // 2, 0]\nX_valid, y_valid = X[m // 2 :], y[m // 2 :, 0]\n\npreprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False),\n                              StandardScaler())\nX_train_prep = preprocessing.fit_transform(X_train)\nX_valid_prep = preprocessing.transform(X_valid)\nsgd_reg = SGDRegressor(penalty=None, eta0=0.002, random_state=42)\nn_epochs = 500\nbest_valid_rmse = float('inf')\ntrain_errors, val_errors = [], []  # extra code – it's for the figure below\n\nfor epoch in range(n_epochs):\n    sgd_reg.partial_fit(X_train_prep, y_train)\n    y_valid_predict = sgd_reg.predict(X_valid_prep)\n    val_error = mean_squared_error(y_valid, y_valid_predict, squared=False)\n    if val_error &lt; best_valid_rmse:\n        best_valid_rmse = val_error\n        best_model = deepcopy(sgd_reg)\n\n    # extra code – we evaluate the train error and save it for the figure\n    y_train_predict = sgd_reg.predict(X_train_prep)\n    train_error = mean_squared_error(y_train, y_train_predict, squared=False)\n    val_errors.append(val_error)\n    train_errors.append(train_error)\n\n# extra code – this section generates and saves Figure 4–20\nbest_epoch = np.argmin(val_errors)\nplt.figure(figsize=(6, 4))\nplt.annotate('Best model',\n             xy=(best_epoch, best_valid_rmse),\n             xytext=(best_epoch, best_valid_rmse + 0.5),\n             ha=\"center\",\n             arrowprops=dict(facecolor='black', shrink=0.05))\nplt.plot([0, n_epochs], [best_valid_rmse, best_valid_rmse], \"k:\", linewidth=2)\nplt.plot(val_errors, \"b-\", linewidth=3, label=\"Validation set\")\nplt.plot(best_epoch, best_valid_rmse, \"bo\")\nplt.plot(train_errors, \"r--\", linewidth=2, label=\"Training set\")\nplt.legend(loc=\"upper right\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"RMSE\")\nplt.axis([0, n_epochs, 0, 3.5])\nplt.grid()\nsave_fig(\"early_stopping_plot\")\nplt.show()"
  },
  {
    "objectID": "blog3.html#estimating-probabilities",
    "href": "blog3.html#estimating-probabilities",
    "title": "Linear and Non-Linear Regression",
    "section": "Estimating Probabilities",
    "text": "Estimating Probabilities\n\n# extra code – generates and saves Figure 4–21\n\nlim = 6\nt = np.linspace(-lim, lim, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.figure(figsize=(8, 3))\nplt.plot([-lim, lim], [0, 0], \"k-\")\nplt.plot([-lim, lim], [0.5, 0.5], \"k:\")\nplt.plot([-lim, lim], [1, 1], \"k:\")\nplt.plot([0, 0], [-1.1, 1.1], \"k-\")\nplt.plot(t, sig, \"b-\", linewidth=2, label=r\"$\\sigma(t) = \\dfrac{1}{1 + e^{-t}}$\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.axis([-lim, lim, -0.1, 1.1])\nplt.gca().set_yticks([0, 0.25, 0.5, 0.75, 1])\nplt.grid()\nsave_fig(\"logistic_function_plot\")\nplt.show()"
  },
  {
    "objectID": "blog3.html#decision-boundaries",
    "href": "blog3.html#decision-boundaries",
    "title": "Linear and Non-Linear Regression",
    "section": "Decision Boundaries",
    "text": "Decision Boundaries\n\nfrom sklearn.datasets import load_iris\n\niris = load_iris(as_frame=True)\nlist(iris)\n\n['data',\n 'target',\n 'frame',\n 'target_names',\n 'DESCR',\n 'feature_names',\n 'filename',\n 'data_module']\n\n\n\nprint(iris.DESCR)  # extra code – it's a bit too long\n\n.. _iris_dataset:\n\nIris plants dataset\n--------------------\n\n**Data Set Characteristics:**\n\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n                \n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThe famous Iris database, first used by Sir R.A. Fisher. The dataset is taken\nfrom Fisher's paper. Note that it's the same as in R, but not as in the UCI\nMachine Learning Repository, which has two wrong data points.\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher's paper is a classic in the field and\nis referenced frequently to this day.  (See Duda & Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\n|details-start|\n**References**\n|details-split|\n\n- Fisher, R.A. \"The use of multiple measurements in taxonomic problems\"\n  Annual Eugenics, 7, Part II, 179-188 (1936); also in \"Contributions to\n  Mathematical Statistics\" (John Wiley, NY, 1950).\n- Duda, R.O., & Hart, P.E. (1973) Pattern Classification and Scene Analysis.\n  (Q327.D83) John Wiley & Sons.  ISBN 0-471-22361-1.  See page 218.\n- Dasarathy, B.V. (1980) \"Nosing Around the Neighborhood: A New System\n  Structure and Classification Rule for Recognition in Partially Exposed\n  Environments\".  IEEE Transactions on Pattern Analysis and Machine\n  Intelligence, Vol. PAMI-2, No. 1, 67-71.\n- Gates, G.W. (1972) \"The Reduced Nearest Neighbor Rule\".  IEEE Transactions\n  on Information Theory, May 1972, 431-433.\n- See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al\"s AUTOCLASS II\n  conceptual clustering system finds 3 classes in the data.\n- Many, many more ...\n\n|details-end|\n\n\n\niris.data.head(3)\n\n\n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n\n\n\n\n\n\niris.target.head(3)  # note that the instances are not shuffled\n\n0    0\n1    0\n2    0\nName: target, dtype: int64\n\n\n\niris.target_names\n\narray(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')\n\n\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\n\nX = iris.data[[\"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(random_state=42)\nlog_reg.fit(X_train, y_train)\n\nLogisticRegression(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=42)\n\n\n\nX_new = np.linspace(0, 3, 1000).reshape(-1, 1)  # reshape to get a column vector\ny_proba = log_reg.predict_proba(X_new)\ndecision_boundary = X_new[y_proba[:, 1] &gt;= 0.5][0, 0]\n\nplt.figure(figsize=(8, 3))  # extra code – not needed, just formatting\nplt.plot(X_new, y_proba[:, 0], \"b--\", linewidth=2,\n         label=\"Not Iris virginica proba\")\nplt.plot(X_new, y_proba[:, 1], \"g-\", linewidth=2, label=\"Iris virginica proba\")\nplt.plot([decision_boundary, decision_boundary], [0, 1], \"k:\", linewidth=2,\n         label=\"Decision boundary\")\n\n# extra code – this section beautifies and saves Figure 4–23\nplt.arrow(x=decision_boundary, y=0.08, dx=-0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"b\", ec=\"b\")\nplt.arrow(x=decision_boundary, y=0.92, dx=0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"g\", ec=\"g\")\nplt.plot(X_train[y_train == 0], y_train[y_train == 0], \"bs\")\nplt.plot(X_train[y_train == 1], y_train[y_train == 1], \"g^\")\nplt.xlabel(\"Petal width (cm)\")\nplt.ylabel(\"Probability\")\nplt.legend(loc=\"center left\")\nplt.axis([0, 3, -0.02, 1.02])\nplt.grid()\nsave_fig(\"logistic_regression_plot\")\n\nplt.show()\n\n\n\n\n\ndecision_boundary\n\n1.6516516516516517\n\n\n\nlog_reg.predict([[1.7], [1.5]])\n\narray([ True, False])\n\n\n\n# extra code – this cell generates and saves Figure 4–24\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(C=2, random_state=42)\nlog_reg.fit(X_train, y_train)\n\n# for the contour plot\nx0, x1 = np.meshgrid(np.linspace(2.9, 7, 500).reshape(-1, 1),\n                     np.linspace(0.8, 2.7, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]  # one instance per point on the figure\ny_proba = log_reg.predict_proba(X_new)\nzz = y_proba[:, 1].reshape(x0.shape)\n\n# for the decision boundary\nleft_right = np.array([2.9, 7])\nboundary = -((log_reg.coef_[0, 0] * left_right + log_reg.intercept_[0])\n             / log_reg.coef_[0, 1])\n\nplt.figure(figsize=(10, 4))\nplt.plot(X_train[y_train == 0, 0], X_train[y_train == 0, 1], \"bs\")\nplt.plot(X_train[y_train == 1, 0], X_train[y_train == 1, 1], \"g^\")\ncontour = plt.contour(x0, x1, zz, cmap=plt.cm.brg)\nplt.clabel(contour, inline=1)\nplt.plot(left_right, boundary, \"k--\", linewidth=3)\nplt.text(3.5, 1.27, \"Not Iris virginica\", color=\"b\", ha=\"center\")\nplt.text(6.5, 2.3, \"Iris virginica\", color=\"g\", ha=\"center\")\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.axis([2.9, 7, 0.8, 2.7])\nplt.grid()\nsave_fig(\"logistic_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog3.html#softmax-regression",
    "href": "blog3.html#softmax-regression",
    "title": "Linear and Non-Linear Regression",
    "section": "Softmax Regression",
    "text": "Softmax Regression\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nsoftmax_reg = LogisticRegression(C=30, random_state=42)\nsoftmax_reg.fit(X_train, y_train)\n\nLogisticRegression(C=30, random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(C=30, random_state=42)\n\n\n\nsoftmax_reg.predict([[5, 2]])\n\narray([2])\n\n\n\nsoftmax_reg.predict_proba([[5, 2]]).round(2)\n\narray([[0.  , 0.04, 0.96]])\n\n\n\n# extra code – this cell generates and saves Figure 4–25\n\nfrom matplotlib.colors import ListedColormap\n\ncustom_cmap = ListedColormap([\"#fafab0\", \"#9898ff\", \"#a0faa0\"])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\n\ny_proba = softmax_reg.predict_proba(X_new)\ny_predict = softmax_reg.predict(X_new)\n\nzz1 = y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"center left\")\nplt.axis([0.5, 7, 0, 3.5])\nplt.grid()\nsave_fig(\"softmax_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog3.html#to-11.",
    "href": "blog3.html#to-11.",
    "title": "Linear and Non-Linear Regression",
    "section": "1. to 11.",
    "text": "1. to 11.\n\nIf you have a training set with millions of features you can use Stochastic Gradient Descent or Mini-batch Gradient Descent, and perhaps Batch Gradient Descent if the training set fits in memory. But you cannot use the Normal Equation or the SVD approach because the computational complexity grows quickly (more than quadratically) with the number of features.\nIf the features in your training set have very different scales, the cost function will have the shape of an elongated bowl, so the Gradient Descent algorithms will take a long time to converge. To solve this you should scale the data before training the model. Note that the Normal Equation or SVD approach will work just fine without scaling. Moreover, regularized models may converge to a suboptimal solution if the features are not scaled: since regularization penalizes large weights, features with smaller values will tend to be ignored compared to features with larger values.\nGradient Descent cannot get stuck in a local minimum when training a Logistic Regression model because the cost function is convex. Convex means that if you draw a straight line between any two points on the curve, the line never crosses the curve.\nIf the optimization problem is convex (such as Linear Regression or Logistic Regression), and assuming the learning rate is not too high, then all Gradient Descent algorithms will approach the global optimum and end up producing fairly similar models. However, unless you gradually reduce the learning rate, Stochastic GD and Mini-batch GD will never truly converge; instead, they will keep jumping back and forth around the global optimum. This means that even if you let them run for a very long time, these Gradient Descent algorithms will produce slightly different models.\nIf the validation error consistently goes up after every epoch, then one possibility is that the learning rate is too high and the algorithm is diverging. If the training error also goes up, then this is clearly the problem and you should reduce the learning rate. However, if the training error is not going up, then your model is overfitting the training set and you should stop training.\nDue to their random nature, neither Stochastic Gradient Descent nor Mini-batch Gradient Descent is guaranteed to make progress at every single training iteration. So if you immediately stop training when the validation error goes up, you may stop much too early, before the optimum is reached. A better option is to save the model at regular intervals; then, when it has not improved for a long time (meaning it will probably never beat the record), you can revert to the best saved model.\nStochastic Gradient Descent has the fastest training iteration since it considers only one training instance at a time, so it is generally the first to reach the vicinity of the global optimum (or Mini-batch GD with a very small mini-batch size). However, only Batch Gradient Descent will actually converge, given enough training time. As mentioned, Stochastic GD and Mini-batch GD will bounce around the optimum, unless you gradually reduce the learning rate.\nIf the validation error is much higher than the training error, this is likely because your model is overfitting the training set. One way to try to fix this is to reduce the polynomial degree: a model with fewer degrees of freedom is less likely to overfit. Another thing you can try is to regularize the model—for example, by adding an ℓ₂ penalty (Ridge) or an ℓ₁ penalty (Lasso) to the cost function. This will also reduce the degrees of freedom of the model. Lastly, you can try to increase the size of the training set.\nIf both the training error and the validation error are almost equal and fairly high, the model is likely underfitting the training set, which means it has a high bias. You should try reducing the regularization hyperparameter α.\nLet’s see:\n\n\nA model with some regularization typically performs better than a model without any regularization, so you should generally prefer Ridge Regression over plain Linear Regression.\nLasso Regression uses an ℓ₁ penalty, which tends to push the weights down to exactly zero. This leads to sparse models, where all weights are zero except for the most important weights. This is a way to perform feature selection automatically, which is good if you suspect that only a few features actually matter. When you are not sure, you should prefer Ridge Regression.\nElastic Net is generally preferred over Lasso since Lasso may behave erratically in some cases (when several features are strongly correlated or when there are more features than training instances). However, it does add an extra hyperparameter to tune. If you want Lasso without the erratic behavior, you can just use Elastic Net with an l1_ratio close to 1.\n\n\nIf you want to classify pictures as outdoor/indoor and daytime/nighttime, since these are not exclusive classes (i.e., all four combinations are possible) you should train two Logistic Regression classifiers."
  },
  {
    "objectID": "blog3.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "href": "blog3.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "title": "Linear and Non-Linear Regression",
    "section": "12. Batch Gradient Descent with early stopping for Softmax Regression",
    "text": "12. Batch Gradient Descent with early stopping for Softmax Regression\nExercise: Implement Batch Gradient Descent with early stopping for Softmax Regression without using Scikit-Learn, only NumPy. Use it on a classification task such as the iris dataset.\nLet’s start by loading the data. We will just reuse the Iris dataset we loaded earlier.\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"].values\n\nWe need to add the bias term for every instance (\\(x_0 = 1\\)). The easiest option to do this would be to use Scikit-Learn’s add_dummy_feature() function, but the point of this exercise is to get a better understanding of the algorithms by implementing them manually. So here is one possible implementation:\n\nX_with_bias = np.c_[np.ones(len(X)), X]\n\nThe easiest option to split the dataset into a training set, a validation set and a test set would be to use Scikit-Learn’s train_test_split() function, but again, we want to do it manually:\n\ntest_ratio = 0.2\nvalidation_ratio = 0.2\ntotal_size = len(X_with_bias)\n\ntest_size = int(total_size * test_ratio)\nvalidation_size = int(total_size * validation_ratio)\ntrain_size = total_size - test_size - validation_size\n\nnp.random.seed(42)\nrnd_indices = np.random.permutation(total_size)\n\nX_train = X_with_bias[rnd_indices[:train_size]]\ny_train = y[rnd_indices[:train_size]]\nX_valid = X_with_bias[rnd_indices[train_size:-test_size]]\ny_valid = y[rnd_indices[train_size:-test_size]]\nX_test = X_with_bias[rnd_indices[-test_size:]]\ny_test = y[rnd_indices[-test_size:]]\n\nThe targets are currently class indices (0, 1 or 2), but we need target class probabilities to train the Softmax Regression model. Each instance will have target class probabilities equal to 0.0 for all classes except for the target class which will have a probability of 1.0 (in other words, the vector of class probabilities for any given instance is a one-hot vector). Let’s write a small function to convert the vector of class indices into a matrix containing a one-hot vector for each instance. To understand this code, you need to know that np.diag(np.ones(n)) creates an n×n matrix full of 0s except for 1s on the main diagonal. Moreover, if a is a NumPy array, then a[[1, 3, 2]] returns an array with 3 rows equal to a[1], a[3] and a[2] (this is advanced NumPy indexing).\n\ndef to_one_hot(y):\n    return np.diag(np.ones(y.max() + 1))[y]\n\nLet’s test this function on the first 10 instances:\n\ny_train[:10]\n\narray([1, 0, 2, 1, 1, 0, 1, 2, 1, 1])\n\n\n\nto_one_hot(y_train[:10])\n\narray([[0., 1., 0.],\n       [1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.],\n       [1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.]])\n\n\nLooks good, so let’s create the target class probabilities matrix for the training set and the test set:\n\nY_train_one_hot = to_one_hot(y_train)\nY_valid_one_hot = to_one_hot(y_valid)\nY_test_one_hot = to_one_hot(y_test)\n\nNow let’s scale the inputs. We compute the mean and standard deviation of each feature on the training set (except for the bias feature), then we center and scale each feature in the training set, the validation set, and the test set:\n\nmean = X_train[:, 1:].mean(axis=0)\nstd = X_train[:, 1:].std(axis=0)\nX_train[:, 1:] = (X_train[:, 1:] - mean) / std\nX_valid[:, 1:] = (X_valid[:, 1:] - mean) / std\nX_test[:, 1:] = (X_test[:, 1:] - mean) / std\n\nNow let’s implement the Softmax function. Recall that it is defined by the following equation:\n\\(\\sigma\\left(\\mathbf{s}(\\mathbf{x})\\right)_k = \\dfrac{\\exp\\left(s_k(\\mathbf{x})\\right)}{\\sum\\limits_{j=1}^{K}{\\exp\\left(s_j(\\mathbf{x})\\right)}}\\)\n\ndef softmax(logits):\n    exps = np.exp(logits)\n    exp_sums = exps.sum(axis=1, keepdims=True)\n    return exps / exp_sums\n\nWe are almost ready to start training. Let’s define the number of inputs and outputs:\n\nn_inputs = X_train.shape[1]  # == 3 (2 features plus the bias term)\nn_outputs = len(np.unique(y_train))  # == 3 (there are 3 iris classes)\n\nNow here comes the hardest part: training! Theoretically, it’s simple: it’s just a matter of translating the math equations into Python code. But in practice, it can be quite tricky: in particular, it’s easy to mix up the order of the terms, or the indices. You can even end up with code that looks like it’s working but is actually not computing exactly the right thing. When unsure, you should write down the shape of each term in the equation and make sure the corresponding terms in your code match closely. It can also help to evaluate each term independently and print them out. The good news it that you won’t have to do this everyday, since all this is well implemented by Scikit-Learn, but it will help you understand what’s going on under the hood.\nSo the equations we will need are the cost function:\n\\(J(\\mathbf{\\Theta}) = - \\dfrac{1}{m}\\sum\\limits_{i=1}^{m}\\sum\\limits_{k=1}^{K}{y_k^{(i)}\\log\\left(\\hat{p}_k^{(i)}\\right)}\\)\nAnd the equation for the gradients:\n\\(\\nabla_{\\mathbf{\\theta}^{(k)}} \\, J(\\mathbf{\\Theta}) = \\dfrac{1}{m} \\sum\\limits_{i=1}^{m}{ \\left ( \\hat{p}^{(i)}_k - y_k^{(i)} \\right ) \\mathbf{x}^{(i)}}\\)\nNote that \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) may not be computable if \\(\\hat{p}_k^{(i)} = 0\\). So we will add a tiny value \\(\\epsilon\\) to \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) to avoid getting nan values.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        print(epoch, xentropy_losses.sum(axis=1).mean())\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    Theta = Theta - eta * gradients\n\n0 3.7085808486476917\n1000 0.14519367480830647\n2000 0.13013095755040877\n3000 0.12009639326384532\n4000 0.11372961364786878\n5000 0.11002459532472424\n\n\nAnd that’s it! The Softmax model is trained. Let’s look at the model parameters:\n\nTheta\n\narray([[ 0.41931626,  6.11112089, -5.52429876],\n       [-6.53054533, -0.74608616,  8.33137102],\n       [-5.28115784,  0.25152675,  6.90680425]])\n\n\nLet’s make predictions for the validation set and check the accuracy score:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nWell, this model looks pretty ok. For the sake of the exercise, let’s add a bit of \\(\\ell_2\\) regularization. The following training code is similar to the one above, but the loss now has an additional \\(\\ell_2\\) penalty, and the gradients have the proper additional term (note that we don’t regularize the first element of Theta since this corresponds to the bias term). Also, let’s try increasing the learning rate eta.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\nalpha = 0.01  # regularization hyperparameter\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n        total_loss = xentropy_losses.sum(axis=1).mean() + alpha * l2_loss\n        print(epoch, total_loss.round(4))\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n1000 0.3259\n2000 0.3259\n3000 0.3259\n4000 0.3259\n5000 0.3259\n\n\nBecause of the additional \\(\\ell_2\\) penalty, the loss seems greater than earlier, but perhaps this model will perform better? Let’s find out:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nIn this case, the \\(\\ell_2\\) penalty did not change the test accuracy. Perhaps try fine-tuning alpha?\nNow let’s add early stopping. For this we just need to measure the loss on the validation set at every iteration and stop when the error starts growing.\n\neta = 0.5\nn_epochs = 50_001\nm = len(X_train)\nepsilon = 1e-5\nC = 100  # regularization hyperparameter\nbest_loss = np.infty\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    Y_proba_valid = softmax(X_valid @ Theta)\n    xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n    l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n    total_loss = xentropy_losses.sum(axis=1).mean() + 1 / C * l2_loss\n    if epoch % 1000 == 0:\n        print(epoch, total_loss.round(4))\n    if total_loss &lt; best_loss:\n        best_loss = total_loss\n    else:\n        print(epoch - 1, best_loss.round(4))\n        print(epoch, total_loss.round(4), \"early stopping!\")\n        break\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), 1 / C * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n281 0.3256\n282 0.3256 early stopping!\n\n\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nOh well, still no change in validation accuracy, but at least early stopping shortened training a bit.\nNow let’s plot the model’s predictions on the whole dataset (remember to scale all features fed to the model):\n\ncustom_cmap = mpl.colors.ListedColormap(['#fafab0', '#9898ff', '#a0faa0'])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\nX_new = (X_new - mean) / std\nX_new_with_bias = np.c_[np.ones(len(X_new)), X_new]\n\nlogits = X_new_with_bias @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\nzz1 = Y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"upper left\")\nplt.axis([0, 7, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\nAnd now let’s measure the final model’s accuracy on the test set:\n\nlogits = X_test @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_test).mean()\naccuracy_score\n\n0.9666666666666667\n\n\nWell we get even better performance on the test set. This variability is likely due to the very small size of the dataset: depending on how you sample the training set, validation set and the test set, you can get quite different results. Try changing the random seed and running the code again a few times, you will see that the results will vary."
  },
  {
    "objectID": "blog4.html",
    "href": "blog4.html",
    "title": "Classification",
    "section": "",
    "text": "Chapter 4 – Training Models\nThis notebook contains all the sample code and solutions to the exercises in chapter 4.\nThis project requires Python 3.7 or above:\nimport sys\n\nassert sys.version_info &gt;= (3, 7)\nIt also requires Scikit-Learn ≥ 1.0.1:\nfrom packaging import version\nimport sklearn\n\nassert version.parse(sklearn.__version__) &gt;= version.parse(\"1.0.1\")\nAs we did in previous chapters, let’s define the default font sizes to make the figures prettier:\nimport matplotlib.pyplot as plt\n\nplt.rc('font', size=14)\nplt.rc('axes', labelsize=14, titlesize=14)\nplt.rc('legend', fontsize=14)\nplt.rc('xtick', labelsize=10)\nplt.rc('ytick', labelsize=10)\nAnd let’s create the images/training_linear_models folder (if it doesn’t already exist), and define the save_fig() function which is used through this notebook to save the figures in high-res for the book:\nfrom pathlib import Path\n\nIMAGES_PATH = Path() / \"images\" / \"training_linear_models\"\nIMAGES_PATH.mkdir(parents=True, exist_ok=True)\n\ndef save_fig(fig_id, tight_layout=True, fig_extension=\"png\", resolution=300):\n    path = IMAGES_PATH / f\"{fig_id}.{fig_extension}\"\n    if tight_layout:\n        plt.tight_layout()\n    plt.savefig(path, format=fig_extension, dpi=resolution)"
  },
  {
    "objectID": "blog4.html#the-normal-equation",
    "href": "blog4.html#the-normal-equation",
    "title": "Classification",
    "section": "The Normal Equation",
    "text": "The Normal Equation\n\nimport numpy as np\n\nnp.random.seed(42)  # to make this code example reproducible\nm = 100  # number of instances\nX = 2 * np.random.rand(m, 1)  # column vector\ny = 4 + 3 * X + np.random.randn(m, 1)  # column vector\n\n\n# extra code – generates and saves Figure 4–1\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"generated_data_plot\")\nplt.show()\n\n\n\n\n\nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)  # add x0 = 1 to each instance\ntheta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n\n\ntheta_best\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\nX_new = np.array([[0], [2]])\nX_new_b = add_dummy_feature(X_new)  # add x0 = 1 to each instance\ny_predict = X_new_b @ theta_best\ny_predict\n\narray([[4.21509616],\n       [9.75532293]])\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\nplt.plot(X_new, y_predict, \"r-\", label=\"Predictions\")\nplt.plot(X, y, \"b.\")\n\n# extra code – beautifies and saves Figure 4–2\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nplt.legend(loc=\"upper left\")\nsave_fig(\"linear_model_predictions_plot\")\n\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\n\nlin_reg = LinearRegression()\nlin_reg.fit(X, y)\nlin_reg.intercept_, lin_reg.coef_\n\n(array([4.21509616]), array([[2.77011339]]))\n\n\n\nlin_reg.predict(X_new)\n\narray([[4.21509616],\n       [9.75532293]])\n\n\nThe LinearRegression class is based on the scipy.linalg.lstsq() function (the name stands for “least squares”), which you could call directly:\n\ntheta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=1e-6)\ntheta_best_svd\n\narray([[4.21509616],\n       [2.77011339]])\n\n\nThis function computes \\(\\mathbf{X}^+\\mathbf{y}\\), where \\(\\mathbf{X}^{+}\\) is the pseudoinverse of \\(\\mathbf{X}\\) (specifically the Moore-Penrose inverse). You can use np.linalg.pinv() to compute the pseudoinverse directly:\n\nnp.linalg.pinv(X_b) @ y\n\narray([[4.21509616],\n       [2.77011339]])"
  },
  {
    "objectID": "blog4.html#batch-gradient-descent",
    "href": "blog4.html#batch-gradient-descent",
    "title": "Classification",
    "section": "Batch Gradient Descent",
    "text": "Batch Gradient Descent\n\neta = 0.1  # learning rate\nn_epochs = 1000\nm = len(X_b)  # number of instances\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # randomly initialized model parameters\n\nfor epoch in range(n_epochs):\n    gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n    theta = theta - eta * gradients\n\nThe trained model parameters:\n\ntheta\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\n# extra code – generates and saves Figure 4–8\n\nimport matplotlib as mpl\n\ndef plot_gradient_descent(theta, eta):\n    m = len(X_b)\n    plt.plot(X, y, \"b.\")\n    n_epochs = 1000\n    n_shown = 20\n    theta_path = []\n    for epoch in range(n_epochs):\n        if epoch &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(epoch / n_shown + 0.15))\n            plt.plot(X_new, y_predict, linestyle=\"solid\", color=color)\n        gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n        theta = theta - eta * gradients\n        theta_path.append(theta)\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 2, 0, 15])\n    plt.grid()\n    plt.title(fr\"$\\eta = {eta}$\")\n    return theta_path\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nplt.figure(figsize=(10, 4))\nplt.subplot(131)\nplot_gradient_descent(theta, eta=0.02)\nplt.ylabel(\"$y$\", rotation=0)\nplt.subplot(132)\ntheta_path_bgd = plot_gradient_descent(theta, eta=0.1)\nplt.gca().axes.yaxis.set_ticklabels([])\nplt.subplot(133)\nplt.gca().axes.yaxis.set_ticklabels([])\nplot_gradient_descent(theta, eta=0.5)\nsave_fig(\"gradient_descent_plot\")\nplt.show()"
  },
  {
    "objectID": "blog4.html#stochastic-gradient-descent",
    "href": "blog4.html#stochastic-gradient-descent",
    "title": "Classification",
    "section": "Stochastic Gradient Descent",
    "text": "Stochastic Gradient Descent\n\ntheta_path_sgd = []  # extra code – we need to store the path of theta in the\n                     #              parameter space to plot the next figure\n\n\nn_epochs = 50\nt0, t1 = 5, 50  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nn_shown = 20  # extra code – just needed to generate the figure below\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\n\nfor epoch in range(n_epochs):\n    for iteration in range(m):\n\n        # extra code – these 4 lines are used to generate the figure\n        if epoch == 0 and iteration &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(iteration / n_shown + 0.15))\n            plt.plot(X_new, y_predict, color=color)\n\n        random_index = np.random.randint(m)\n        xi = X_b[random_index : random_index + 1]\n        yi = y[random_index : random_index + 1]\n        gradients = 2 * xi.T @ (xi @ theta - yi)  # for SGD, do not divide by m\n        eta = learning_schedule(epoch * m + iteration)\n        theta = theta - eta * gradients\n        theta_path_sgd.append(theta)  # extra code – to generate the figure\n\n# extra code – this section beautifies and saves Figure 4–10\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"sgd_plot\")\nplt.show()\n\n\n\n\n\ntheta\n\narray([[4.21076011],\n       [2.74856079]])\n\n\n\nfrom sklearn.linear_model import SGDRegressor\n\nsgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, penalty=None, eta0=0.01,\n                       n_iter_no_change=100, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\n\nSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SGDRegressorSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)\n\n\n\nsgd_reg.intercept_, sgd_reg.coef_\n\n(array([4.21278812]), array([2.77270267]))"
  },
  {
    "objectID": "blog4.html#mini-batch-gradient-descent",
    "href": "blog4.html#mini-batch-gradient-descent",
    "title": "Classification",
    "section": "Mini-batch gradient descent",
    "text": "Mini-batch gradient descent\nThe code in this section is used to generate the next figure, it is not in the book.\n\n# extra code – this cell generates and saves Figure 4–11\n\nfrom math import ceil\n\nn_epochs = 50\nminibatch_size = 20\nn_batches_per_epoch = ceil(m / minibatch_size)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nt0, t1 = 200, 1000  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\ntheta_path_mgd = []\nfor epoch in range(n_epochs):\n    shuffled_indices = np.random.permutation(m)\n    X_b_shuffled = X_b[shuffled_indices]\n    y_shuffled = y[shuffled_indices]\n    for iteration in range(0, n_batches_per_epoch):\n        idx = iteration * minibatch_size\n        xi = X_b_shuffled[idx : idx + minibatch_size]\n        yi = y_shuffled[idx : idx + minibatch_size]\n        gradients = 2 / minibatch_size * xi.T @ (xi @ theta - yi)\n        eta = learning_schedule(iteration)\n        theta = theta - eta * gradients\n        theta_path_mgd.append(theta)\n\ntheta_path_bgd = np.array(theta_path_bgd)\ntheta_path_sgd = np.array(theta_path_sgd)\ntheta_path_mgd = np.array(theta_path_mgd)\n\nplt.figure(figsize=(7, 4))\nplt.plot(theta_path_sgd[:, 0], theta_path_sgd[:, 1], \"r-s\", linewidth=1,\n         label=\"Stochastic\")\nplt.plot(theta_path_mgd[:, 0], theta_path_mgd[:, 1], \"g-+\", linewidth=2,\n         label=\"Mini-batch\")\nplt.plot(theta_path_bgd[:, 0], theta_path_bgd[:, 1], \"b-o\", linewidth=3,\n         label=\"Batch\")\nplt.legend(loc=\"upper left\")\nplt.xlabel(r\"$\\theta_0$\")\nplt.ylabel(r\"$\\theta_1$   \", rotation=0)\nplt.axis([2.6, 4.6, 2.3, 3.4])\nplt.grid()\nsave_fig(\"gradient_descent_paths_plot\")\nplt.show()"
  },
  {
    "objectID": "blog4.html#ridge-regression",
    "href": "blog4.html#ridge-regression",
    "title": "Classification",
    "section": "Ridge Regression",
    "text": "Ridge Regression\nLet’s generate a very small and noisy linear dataset:\n\n# extra code – we've done this type of generation several times before\nnp.random.seed(42)\nm = 20\nX = 3 * np.random.rand(m, 1)\ny = 1 + 0.5 * X + np.random.randn(m, 1) / 1.5\nX_new = np.linspace(0, 3, 100).reshape(100, 1)\n\n\n# extra code – a quick peek at the dataset we just generated\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \".\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$  \", rotation=0)\nplt.axis([0, 3, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import Ridge\n\nridge_reg = Ridge(alpha=0.1, solver=\"cholesky\")\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55325833]])\n\n\n\n# extra code – this cell generates and saves Figure 4–17\n\ndef plot_model(model_class, polynomial, alphas, **model_kwargs):\n    plt.plot(X, y, \"b.\", linewidth=3)\n    for alpha, style in zip(alphas, (\"b:\", \"g--\", \"r-\")):\n        if alpha &gt; 0:\n            model = model_class(alpha, **model_kwargs)\n        else:\n            model = LinearRegression()\n        if polynomial:\n            model = make_pipeline(\n                PolynomialFeatures(degree=10, include_bias=False),\n                StandardScaler(),\n                model)\n        model.fit(X, y)\n        y_new_regul = model.predict(X_new)\n        plt.plot(X_new, y_new_regul, style, linewidth=2,\n                 label=fr\"$\\alpha = {alpha}$\")\n    plt.legend(loc=\"upper left\")\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 3, 0, 3.5])\n    plt.grid()\n\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Ridge, polynomial=False, alphas=(0, 10, 100), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Ridge, polynomial=True, alphas=(0, 10**-5, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"ridge_regression_plot\")\nplt.show()\n\n\n\n\n\nsgd_reg = SGDRegressor(penalty=\"l2\", alpha=0.1 / m, tol=None,\n                       max_iter=1000, eta0=0.01, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\nsgd_reg.predict([[1.5]])\n\narray([1.55302613])\n\n\n\n# extra code – show that we get roughly the same solution as earlier when\n#              we use Stochastic Average GD (solver=\"sag\")\nridge_reg = Ridge(alpha=0.1, solver=\"sag\", random_state=42)\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55326019]])\n\n\n\n# extra code – shows the closed form solution of Ridge regression,\n#              compare with the next Ridge model's learned parameters below\nalpha = 0.1\nA = np.array([[0., 0.], [0., 1.]])\nX_b = np.c_[np.ones(m), X]\nnp.linalg.inv(X_b.T @ X_b + alpha * A) @ X_b.T @ y\n\narray([[0.97898394],\n       [0.3828496 ]])\n\n\n\nridge_reg.intercept_, ridge_reg.coef_  # extra code\n\n(array([0.97896386]), array([[0.38286422]]))"
  },
  {
    "objectID": "blog4.html#lasso-regression",
    "href": "blog4.html#lasso-regression",
    "title": "Classification",
    "section": "Lasso Regression",
    "text": "Lasso Regression\n\nfrom sklearn.linear_model import Lasso\n\nlasso_reg = Lasso(alpha=0.1)\nlasso_reg.fit(X, y)\nlasso_reg.predict([[1.5]])\n\narray([1.53788174])\n\n\n\n# extra code – this cell generates and saves Figure 4–18\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Lasso, polynomial=False, alphas=(0, 0.1, 1), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Lasso, polynomial=True, alphas=(0, 1e-2, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"lasso_regression_plot\")\nplt.show()\n\n\n\n\n\n# extra code – this BIG cell generates and saves Figure 4–19\n\nt1a, t1b, t2a, t2b = -1, 3, -1.5, 1.5\n\nt1s = np.linspace(t1a, t1b, 500)\nt2s = np.linspace(t2a, t2b, 500)\nt1, t2 = np.meshgrid(t1s, t2s)\nT = np.c_[t1.ravel(), t2.ravel()]\nXr = np.array([[1, 1], [1, -1], [1, 0.5]])\nyr = 2 * Xr[:, :1] + 0.5 * Xr[:, 1:]\n\nJ = (1 / len(Xr) * ((T @ Xr.T - yr.T) ** 2).sum(axis=1)).reshape(t1.shape)\n\nN1 = np.linalg.norm(T, ord=1, axis=1).reshape(t1.shape)\nN2 = np.linalg.norm(T, ord=2, axis=1).reshape(t1.shape)\n\nt_min_idx = np.unravel_index(J.argmin(), J.shape)\nt1_min, t2_min = t1[t_min_idx], t2[t_min_idx]\n\nt_init = np.array([[0.25], [-1]])\n\ndef bgd_path(theta, X, y, l1, l2, core=1, eta=0.05, n_iterations=200):\n    path = [theta]\n    for iteration in range(n_iterations):\n        gradients = (core * 2 / len(X) * X.T @ (X @ theta - y)\n                     + l1 * np.sign(theta) + l2 * theta)\n        theta = theta - eta * gradients\n        path.append(theta)\n    return np.array(path)\n\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(10.1, 8))\n\nfor i, N, l1, l2, title in ((0, N1, 2.0, 0, \"Lasso\"), (1, N2, 0, 2.0, \"Ridge\")):\n    JR = J + l1 * N1 + l2 * 0.5 * N2 ** 2\n\n    tr_min_idx = np.unravel_index(JR.argmin(), JR.shape)\n    t1r_min, t2r_min = t1[tr_min_idx], t2[tr_min_idx]\n\n    levels = np.exp(np.linspace(0, 1, 20)) - 1\n    levelsJ = levels * (J.max() - J.min()) + J.min()\n    levelsJR = levels * (JR.max() - JR.min()) + JR.min()\n    levelsN = np.linspace(0, N.max(), 10)\n\n    path_J = bgd_path(t_init, Xr, yr, l1=0, l2=0)\n    path_JR = bgd_path(t_init, Xr, yr, l1, l2)\n    path_N = bgd_path(theta=np.array([[2.0], [0.5]]), X=Xr, y=yr,\n                      l1=np.sign(l1) / 3, l2=np.sign(l2), core=0)\n    ax = axes[i, 0]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, N / 2.0, levels=levelsN)\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.set_title(fr\"$\\ell_{i + 1}$ penalty\")\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n    ax.set_ylabel(r\"$\\theta_2$\", rotation=0)\n\n    ax = axes[i, 1]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, JR, levels=levelsJR, alpha=0.9)\n    ax.plot(path_JR[:, 0], path_JR[:, 1], \"w-o\")\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.plot(t1r_min, t2r_min, \"rs\")\n    ax.set_title(title)\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n\nsave_fig(\"lasso_vs_ridge_plot\")\nplt.show()"
  },
  {
    "objectID": "blog4.html#elastic-net",
    "href": "blog4.html#elastic-net",
    "title": "Classification",
    "section": "Elastic Net",
    "text": "Elastic Net\n\nfrom sklearn.linear_model import ElasticNet\n\nelastic_net = ElasticNet(alpha=0.1, l1_ratio=0.5)\nelastic_net.fit(X, y)\nelastic_net.predict([[1.5]])\n\narray([1.54333232])"
  },
  {
    "objectID": "blog4.html#early-stopping",
    "href": "blog4.html#early-stopping",
    "title": "Classification",
    "section": "Early Stopping",
    "text": "Early Stopping\nLet’s go back to the quadratic dataset we used earlier:\n\nfrom copy import deepcopy\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# extra code – creates the same quadratic dataset as earlier and splits it\nnp.random.seed(42)\nm = 100\nX = 6 * np.random.rand(m, 1) - 3\ny = 0.5 * X ** 2 + X + 2 + np.random.randn(m, 1)\nX_train, y_train = X[: m // 2], y[: m // 2, 0]\nX_valid, y_valid = X[m // 2 :], y[m // 2 :, 0]\n\npreprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False),\n                              StandardScaler())\nX_train_prep = preprocessing.fit_transform(X_train)\nX_valid_prep = preprocessing.transform(X_valid)\nsgd_reg = SGDRegressor(penalty=None, eta0=0.002, random_state=42)\nn_epochs = 500\nbest_valid_rmse = float('inf')\ntrain_errors, val_errors = [], []  # extra code – it's for the figure below\n\nfor epoch in range(n_epochs):\n    sgd_reg.partial_fit(X_train_prep, y_train)\n    y_valid_predict = sgd_reg.predict(X_valid_prep)\n    val_error = mean_squared_error(y_valid, y_valid_predict, squared=False)\n    if val_error &lt; best_valid_rmse:\n        best_valid_rmse = val_error\n        best_model = deepcopy(sgd_reg)\n\n    # extra code – we evaluate the train error and save it for the figure\n    y_train_predict = sgd_reg.predict(X_train_prep)\n    train_error = mean_squared_error(y_train, y_train_predict, squared=False)\n    val_errors.append(val_error)\n    train_errors.append(train_error)\n\n# extra code – this section generates and saves Figure 4–20\nbest_epoch = np.argmin(val_errors)\nplt.figure(figsize=(6, 4))\nplt.annotate('Best model',\n             xy=(best_epoch, best_valid_rmse),\n             xytext=(best_epoch, best_valid_rmse + 0.5),\n             ha=\"center\",\n             arrowprops=dict(facecolor='black', shrink=0.05))\nplt.plot([0, n_epochs], [best_valid_rmse, best_valid_rmse], \"k:\", linewidth=2)\nplt.plot(val_errors, \"b-\", linewidth=3, label=\"Validation set\")\nplt.plot(best_epoch, best_valid_rmse, \"bo\")\nplt.plot(train_errors, \"r--\", linewidth=2, label=\"Training set\")\nplt.legend(loc=\"upper right\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"RMSE\")\nplt.axis([0, n_epochs, 0, 3.5])\nplt.grid()\nsave_fig(\"early_stopping_plot\")\nplt.show()"
  },
  {
    "objectID": "blog4.html#estimating-probabilities",
    "href": "blog4.html#estimating-probabilities",
    "title": "Classification",
    "section": "Estimating Probabilities",
    "text": "Estimating Probabilities\n\n# extra code – generates and saves Figure 4–21\n\nlim = 6\nt = np.linspace(-lim, lim, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.figure(figsize=(8, 3))\nplt.plot([-lim, lim], [0, 0], \"k-\")\nplt.plot([-lim, lim], [0.5, 0.5], \"k:\")\nplt.plot([-lim, lim], [1, 1], \"k:\")\nplt.plot([0, 0], [-1.1, 1.1], \"k-\")\nplt.plot(t, sig, \"b-\", linewidth=2, label=r\"$\\sigma(t) = \\dfrac{1}{1 + e^{-t}}$\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.axis([-lim, lim, -0.1, 1.1])\nplt.gca().set_yticks([0, 0.25, 0.5, 0.75, 1])\nplt.grid()\nsave_fig(\"logistic_function_plot\")\nplt.show()"
  },
  {
    "objectID": "blog4.html#decision-boundaries",
    "href": "blog4.html#decision-boundaries",
    "title": "Classification",
    "section": "Decision Boundaries",
    "text": "Decision Boundaries\n\nfrom sklearn.datasets import load_iris\n\niris = load_iris(as_frame=True)\nlist(iris)\n\n['data',\n 'target',\n 'frame',\n 'target_names',\n 'DESCR',\n 'feature_names',\n 'filename',\n 'data_module']\n\n\n\nprint(iris.DESCR)  # extra code – it's a bit too long\n\n.. _iris_dataset:\n\nIris plants dataset\n--------------------\n\n**Data Set Characteristics:**\n\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n                \n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThe famous Iris database, first used by Sir R.A. Fisher. The dataset is taken\nfrom Fisher's paper. Note that it's the same as in R, but not as in the UCI\nMachine Learning Repository, which has two wrong data points.\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher's paper is a classic in the field and\nis referenced frequently to this day.  (See Duda & Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\n|details-start|\n**References**\n|details-split|\n\n- Fisher, R.A. \"The use of multiple measurements in taxonomic problems\"\n  Annual Eugenics, 7, Part II, 179-188 (1936); also in \"Contributions to\n  Mathematical Statistics\" (John Wiley, NY, 1950).\n- Duda, R.O., & Hart, P.E. (1973) Pattern Classification and Scene Analysis.\n  (Q327.D83) John Wiley & Sons.  ISBN 0-471-22361-1.  See page 218.\n- Dasarathy, B.V. (1980) \"Nosing Around the Neighborhood: A New System\n  Structure and Classification Rule for Recognition in Partially Exposed\n  Environments\".  IEEE Transactions on Pattern Analysis and Machine\n  Intelligence, Vol. PAMI-2, No. 1, 67-71.\n- Gates, G.W. (1972) \"The Reduced Nearest Neighbor Rule\".  IEEE Transactions\n  on Information Theory, May 1972, 431-433.\n- See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al\"s AUTOCLASS II\n  conceptual clustering system finds 3 classes in the data.\n- Many, many more ...\n\n|details-end|\n\n\n\niris.data.head(3)\n\n\n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n\n\n\n\n\n\niris.target.head(3)  # note that the instances are not shuffled\n\n0    0\n1    0\n2    0\nName: target, dtype: int64\n\n\n\niris.target_names\n\narray(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')\n\n\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\n\nX = iris.data[[\"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(random_state=42)\nlog_reg.fit(X_train, y_train)\n\nLogisticRegression(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=42)\n\n\n\nX_new = np.linspace(0, 3, 1000).reshape(-1, 1)  # reshape to get a column vector\ny_proba = log_reg.predict_proba(X_new)\ndecision_boundary = X_new[y_proba[:, 1] &gt;= 0.5][0, 0]\n\nplt.figure(figsize=(8, 3))  # extra code – not needed, just formatting\nplt.plot(X_new, y_proba[:, 0], \"b--\", linewidth=2,\n         label=\"Not Iris virginica proba\")\nplt.plot(X_new, y_proba[:, 1], \"g-\", linewidth=2, label=\"Iris virginica proba\")\nplt.plot([decision_boundary, decision_boundary], [0, 1], \"k:\", linewidth=2,\n         label=\"Decision boundary\")\n\n# extra code – this section beautifies and saves Figure 4–23\nplt.arrow(x=decision_boundary, y=0.08, dx=-0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"b\", ec=\"b\")\nplt.arrow(x=decision_boundary, y=0.92, dx=0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"g\", ec=\"g\")\nplt.plot(X_train[y_train == 0], y_train[y_train == 0], \"bs\")\nplt.plot(X_train[y_train == 1], y_train[y_train == 1], \"g^\")\nplt.xlabel(\"Petal width (cm)\")\nplt.ylabel(\"Probability\")\nplt.legend(loc=\"center left\")\nplt.axis([0, 3, -0.02, 1.02])\nplt.grid()\nsave_fig(\"logistic_regression_plot\")\n\nplt.show()\n\n\n\n\n\ndecision_boundary\n\n1.6516516516516517\n\n\n\nlog_reg.predict([[1.7], [1.5]])\n\narray([ True, False])\n\n\n\n# extra code – this cell generates and saves Figure 4–24\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(C=2, random_state=42)\nlog_reg.fit(X_train, y_train)\n\n# for the contour plot\nx0, x1 = np.meshgrid(np.linspace(2.9, 7, 500).reshape(-1, 1),\n                     np.linspace(0.8, 2.7, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]  # one instance per point on the figure\ny_proba = log_reg.predict_proba(X_new)\nzz = y_proba[:, 1].reshape(x0.shape)\n\n# for the decision boundary\nleft_right = np.array([2.9, 7])\nboundary = -((log_reg.coef_[0, 0] * left_right + log_reg.intercept_[0])\n             / log_reg.coef_[0, 1])\n\nplt.figure(figsize=(10, 4))\nplt.plot(X_train[y_train == 0, 0], X_train[y_train == 0, 1], \"bs\")\nplt.plot(X_train[y_train == 1, 0], X_train[y_train == 1, 1], \"g^\")\ncontour = plt.contour(x0, x1, zz, cmap=plt.cm.brg)\nplt.clabel(contour, inline=1)\nplt.plot(left_right, boundary, \"k--\", linewidth=3)\nplt.text(3.5, 1.27, \"Not Iris virginica\", color=\"b\", ha=\"center\")\nplt.text(6.5, 2.3, \"Iris virginica\", color=\"g\", ha=\"center\")\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.axis([2.9, 7, 0.8, 2.7])\nplt.grid()\nsave_fig(\"logistic_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog4.html#softmax-regression",
    "href": "blog4.html#softmax-regression",
    "title": "Classification",
    "section": "Softmax Regression",
    "text": "Softmax Regression\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nsoftmax_reg = LogisticRegression(C=30, random_state=42)\nsoftmax_reg.fit(X_train, y_train)\n\nLogisticRegression(C=30, random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(C=30, random_state=42)\n\n\n\nsoftmax_reg.predict([[5, 2]])\n\narray([2])\n\n\n\nsoftmax_reg.predict_proba([[5, 2]]).round(2)\n\narray([[0.  , 0.04, 0.96]])\n\n\n\n# extra code – this cell generates and saves Figure 4–25\n\nfrom matplotlib.colors import ListedColormap\n\ncustom_cmap = ListedColormap([\"#fafab0\", \"#9898ff\", \"#a0faa0\"])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\n\ny_proba = softmax_reg.predict_proba(X_new)\ny_predict = softmax_reg.predict(X_new)\n\nzz1 = y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"center left\")\nplt.axis([0.5, 7, 0, 3.5])\nplt.grid()\nsave_fig(\"softmax_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog4.html#to-11.",
    "href": "blog4.html#to-11.",
    "title": "Classification",
    "section": "1. to 11.",
    "text": "1. to 11.\n\nIf you have a training set with millions of features you can use Stochastic Gradient Descent or Mini-batch Gradient Descent, and perhaps Batch Gradient Descent if the training set fits in memory. But you cannot use the Normal Equation or the SVD approach because the computational complexity grows quickly (more than quadratically) with the number of features.\nIf the features in your training set have very different scales, the cost function will have the shape of an elongated bowl, so the Gradient Descent algorithms will take a long time to converge. To solve this you should scale the data before training the model. Note that the Normal Equation or SVD approach will work just fine without scaling. Moreover, regularized models may converge to a suboptimal solution if the features are not scaled: since regularization penalizes large weights, features with smaller values will tend to be ignored compared to features with larger values.\nGradient Descent cannot get stuck in a local minimum when training a Logistic Regression model because the cost function is convex. Convex means that if you draw a straight line between any two points on the curve, the line never crosses the curve.\nIf the optimization problem is convex (such as Linear Regression or Logistic Regression), and assuming the learning rate is not too high, then all Gradient Descent algorithms will approach the global optimum and end up producing fairly similar models. However, unless you gradually reduce the learning rate, Stochastic GD and Mini-batch GD will never truly converge; instead, they will keep jumping back and forth around the global optimum. This means that even if you let them run for a very long time, these Gradient Descent algorithms will produce slightly different models.\nIf the validation error consistently goes up after every epoch, then one possibility is that the learning rate is too high and the algorithm is diverging. If the training error also goes up, then this is clearly the problem and you should reduce the learning rate. However, if the training error is not going up, then your model is overfitting the training set and you should stop training.\nDue to their random nature, neither Stochastic Gradient Descent nor Mini-batch Gradient Descent is guaranteed to make progress at every single training iteration. So if you immediately stop training when the validation error goes up, you may stop much too early, before the optimum is reached. A better option is to save the model at regular intervals; then, when it has not improved for a long time (meaning it will probably never beat the record), you can revert to the best saved model.\nStochastic Gradient Descent has the fastest training iteration since it considers only one training instance at a time, so it is generally the first to reach the vicinity of the global optimum (or Mini-batch GD with a very small mini-batch size). However, only Batch Gradient Descent will actually converge, given enough training time. As mentioned, Stochastic GD and Mini-batch GD will bounce around the optimum, unless you gradually reduce the learning rate.\nIf the validation error is much higher than the training error, this is likely because your model is overfitting the training set. One way to try to fix this is to reduce the polynomial degree: a model with fewer degrees of freedom is less likely to overfit. Another thing you can try is to regularize the model—for example, by adding an ℓ₂ penalty (Ridge) or an ℓ₁ penalty (Lasso) to the cost function. This will also reduce the degrees of freedom of the model. Lastly, you can try to increase the size of the training set.\nIf both the training error and the validation error are almost equal and fairly high, the model is likely underfitting the training set, which means it has a high bias. You should try reducing the regularization hyperparameter α.\nLet’s see:\n\n\nA model with some regularization typically performs better than a model without any regularization, so you should generally prefer Ridge Regression over plain Linear Regression.\nLasso Regression uses an ℓ₁ penalty, which tends to push the weights down to exactly zero. This leads to sparse models, where all weights are zero except for the most important weights. This is a way to perform feature selection automatically, which is good if you suspect that only a few features actually matter. When you are not sure, you should prefer Ridge Regression.\nElastic Net is generally preferred over Lasso since Lasso may behave erratically in some cases (when several features are strongly correlated or when there are more features than training instances). However, it does add an extra hyperparameter to tune. If you want Lasso without the erratic behavior, you can just use Elastic Net with an l1_ratio close to 1.\n\n\nIf you want to classify pictures as outdoor/indoor and daytime/nighttime, since these are not exclusive classes (i.e., all four combinations are possible) you should train two Logistic Regression classifiers."
  },
  {
    "objectID": "blog4.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "href": "blog4.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "title": "Classification",
    "section": "12. Batch Gradient Descent with early stopping for Softmax Regression",
    "text": "12. Batch Gradient Descent with early stopping for Softmax Regression\nExercise: Implement Batch Gradient Descent with early stopping for Softmax Regression without using Scikit-Learn, only NumPy. Use it on a classification task such as the iris dataset.\nLet’s start by loading the data. We will just reuse the Iris dataset we loaded earlier.\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"].values\n\nWe need to add the bias term for every instance (\\(x_0 = 1\\)). The easiest option to do this would be to use Scikit-Learn’s add_dummy_feature() function, but the point of this exercise is to get a better understanding of the algorithms by implementing them manually. So here is one possible implementation:\n\nX_with_bias = np.c_[np.ones(len(X)), X]\n\nThe easiest option to split the dataset into a training set, a validation set and a test set would be to use Scikit-Learn’s train_test_split() function, but again, we want to do it manually:\n\ntest_ratio = 0.2\nvalidation_ratio = 0.2\ntotal_size = len(X_with_bias)\n\ntest_size = int(total_size * test_ratio)\nvalidation_size = int(total_size * validation_ratio)\ntrain_size = total_size - test_size - validation_size\n\nnp.random.seed(42)\nrnd_indices = np.random.permutation(total_size)\n\nX_train = X_with_bias[rnd_indices[:train_size]]\ny_train = y[rnd_indices[:train_size]]\nX_valid = X_with_bias[rnd_indices[train_size:-test_size]]\ny_valid = y[rnd_indices[train_size:-test_size]]\nX_test = X_with_bias[rnd_indices[-test_size:]]\ny_test = y[rnd_indices[-test_size:]]\n\nThe targets are currently class indices (0, 1 or 2), but we need target class probabilities to train the Softmax Regression model. Each instance will have target class probabilities equal to 0.0 for all classes except for the target class which will have a probability of 1.0 (in other words, the vector of class probabilities for any given instance is a one-hot vector). Let’s write a small function to convert the vector of class indices into a matrix containing a one-hot vector for each instance. To understand this code, you need to know that np.diag(np.ones(n)) creates an n×n matrix full of 0s except for 1s on the main diagonal. Moreover, if a is a NumPy array, then a[[1, 3, 2]] returns an array with 3 rows equal to a[1], a[3] and a[2] (this is advanced NumPy indexing).\n\ndef to_one_hot(y):\n    return np.diag(np.ones(y.max() + 1))[y]\n\nLet’s test this function on the first 10 instances:\n\ny_train[:10]\n\narray([1, 0, 2, 1, 1, 0, 1, 2, 1, 1])\n\n\n\nto_one_hot(y_train[:10])\n\narray([[0., 1., 0.],\n       [1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.],\n       [1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.]])\n\n\nLooks good, so let’s create the target class probabilities matrix for the training set and the test set:\n\nY_train_one_hot = to_one_hot(y_train)\nY_valid_one_hot = to_one_hot(y_valid)\nY_test_one_hot = to_one_hot(y_test)\n\nNow let’s scale the inputs. We compute the mean and standard deviation of each feature on the training set (except for the bias feature), then we center and scale each feature in the training set, the validation set, and the test set:\n\nmean = X_train[:, 1:].mean(axis=0)\nstd = X_train[:, 1:].std(axis=0)\nX_train[:, 1:] = (X_train[:, 1:] - mean) / std\nX_valid[:, 1:] = (X_valid[:, 1:] - mean) / std\nX_test[:, 1:] = (X_test[:, 1:] - mean) / std\n\nNow let’s implement the Softmax function. Recall that it is defined by the following equation:\n\\(\\sigma\\left(\\mathbf{s}(\\mathbf{x})\\right)_k = \\dfrac{\\exp\\left(s_k(\\mathbf{x})\\right)}{\\sum\\limits_{j=1}^{K}{\\exp\\left(s_j(\\mathbf{x})\\right)}}\\)\n\ndef softmax(logits):\n    exps = np.exp(logits)\n    exp_sums = exps.sum(axis=1, keepdims=True)\n    return exps / exp_sums\n\nWe are almost ready to start training. Let’s define the number of inputs and outputs:\n\nn_inputs = X_train.shape[1]  # == 3 (2 features plus the bias term)\nn_outputs = len(np.unique(y_train))  # == 3 (there are 3 iris classes)\n\nNow here comes the hardest part: training! Theoretically, it’s simple: it’s just a matter of translating the math equations into Python code. But in practice, it can be quite tricky: in particular, it’s easy to mix up the order of the terms, or the indices. You can even end up with code that looks like it’s working but is actually not computing exactly the right thing. When unsure, you should write down the shape of each term in the equation and make sure the corresponding terms in your code match closely. It can also help to evaluate each term independently and print them out. The good news it that you won’t have to do this everyday, since all this is well implemented by Scikit-Learn, but it will help you understand what’s going on under the hood.\nSo the equations we will need are the cost function:\n\\(J(\\mathbf{\\Theta}) = - \\dfrac{1}{m}\\sum\\limits_{i=1}^{m}\\sum\\limits_{k=1}^{K}{y_k^{(i)}\\log\\left(\\hat{p}_k^{(i)}\\right)}\\)\nAnd the equation for the gradients:\n\\(\\nabla_{\\mathbf{\\theta}^{(k)}} \\, J(\\mathbf{\\Theta}) = \\dfrac{1}{m} \\sum\\limits_{i=1}^{m}{ \\left ( \\hat{p}^{(i)}_k - y_k^{(i)} \\right ) \\mathbf{x}^{(i)}}\\)\nNote that \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) may not be computable if \\(\\hat{p}_k^{(i)} = 0\\). So we will add a tiny value \\(\\epsilon\\) to \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) to avoid getting nan values.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        print(epoch, xentropy_losses.sum(axis=1).mean())\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    Theta = Theta - eta * gradients\n\n0 3.7085808486476917\n1000 0.14519367480830647\n2000 0.13013095755040877\n3000 0.12009639326384532\n4000 0.11372961364786878\n5000 0.11002459532472424\n\n\nAnd that’s it! The Softmax model is trained. Let’s look at the model parameters:\n\nTheta\n\narray([[ 0.41931626,  6.11112089, -5.52429876],\n       [-6.53054533, -0.74608616,  8.33137102],\n       [-5.28115784,  0.25152675,  6.90680425]])\n\n\nLet’s make predictions for the validation set and check the accuracy score:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nWell, this model looks pretty ok. For the sake of the exercise, let’s add a bit of \\(\\ell_2\\) regularization. The following training code is similar to the one above, but the loss now has an additional \\(\\ell_2\\) penalty, and the gradients have the proper additional term (note that we don’t regularize the first element of Theta since this corresponds to the bias term). Also, let’s try increasing the learning rate eta.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\nalpha = 0.01  # regularization hyperparameter\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n        total_loss = xentropy_losses.sum(axis=1).mean() + alpha * l2_loss\n        print(epoch, total_loss.round(4))\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n1000 0.3259\n2000 0.3259\n3000 0.3259\n4000 0.3259\n5000 0.3259\n\n\nBecause of the additional \\(\\ell_2\\) penalty, the loss seems greater than earlier, but perhaps this model will perform better? Let’s find out:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nIn this case, the \\(\\ell_2\\) penalty did not change the test accuracy. Perhaps try fine-tuning alpha?\nNow let’s add early stopping. For this we just need to measure the loss on the validation set at every iteration and stop when the error starts growing.\n\neta = 0.5\nn_epochs = 50_001\nm = len(X_train)\nepsilon = 1e-5\nC = 100  # regularization hyperparameter\nbest_loss = np.infty\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    Y_proba_valid = softmax(X_valid @ Theta)\n    xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n    l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n    total_loss = xentropy_losses.sum(axis=1).mean() + 1 / C * l2_loss\n    if epoch % 1000 == 0:\n        print(epoch, total_loss.round(4))\n    if total_loss &lt; best_loss:\n        best_loss = total_loss\n    else:\n        print(epoch - 1, best_loss.round(4))\n        print(epoch, total_loss.round(4), \"early stopping!\")\n        break\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), 1 / C * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n281 0.3256\n282 0.3256 early stopping!\n\n\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nOh well, still no change in validation accuracy, but at least early stopping shortened training a bit.\nNow let’s plot the model’s predictions on the whole dataset (remember to scale all features fed to the model):\n\ncustom_cmap = mpl.colors.ListedColormap(['#fafab0', '#9898ff', '#a0faa0'])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\nX_new = (X_new - mean) / std\nX_new_with_bias = np.c_[np.ones(len(X_new)), X_new]\n\nlogits = X_new_with_bias @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\nzz1 = Y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"upper left\")\nplt.axis([0, 7, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\nAnd now let’s measure the final model’s accuracy on the test set:\n\nlogits = X_test @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_test).mean()\naccuracy_score\n\n0.9666666666666667\n\n\nWell we get even better performance on the test set. This variability is likely due to the very small size of the dataset: depending on how you sample the training set, validation set and the test set, you can get quite different results. Try changing the random seed and running the code again a few times, you will see that the results will vary."
  },
  {
    "objectID": "blog5.html",
    "href": "blog5.html",
    "title": "Anomaly Detection",
    "section": "",
    "text": "Chapter 4 – Training Models\nThis notebook contains all the sample code and solutions to the exercises in chapter 4.\nThis project requires Python 3.7 or above:\nimport sys\n\nassert sys.version_info &gt;= (3, 7)\nIt also requires Scikit-Learn ≥ 1.0.1:\nfrom packaging import version\nimport sklearn\n\nassert version.parse(sklearn.__version__) &gt;= version.parse(\"1.0.1\")\nAs we did in previous chapters, let’s define the default font sizes to make the figures prettier:\nimport matplotlib.pyplot as plt\n\nplt.rc('font', size=14)\nplt.rc('axes', labelsize=14, titlesize=14)\nplt.rc('legend', fontsize=14)\nplt.rc('xtick', labelsize=10)\nplt.rc('ytick', labelsize=10)\nAnd let’s create the images/training_linear_models folder (if it doesn’t already exist), and define the save_fig() function which is used through this notebook to save the figures in high-res for the book:\nfrom pathlib import Path\n\nIMAGES_PATH = Path() / \"images\" / \"training_linear_models\"\nIMAGES_PATH.mkdir(parents=True, exist_ok=True)\n\ndef save_fig(fig_id, tight_layout=True, fig_extension=\"png\", resolution=300):\n    path = IMAGES_PATH / f\"{fig_id}.{fig_extension}\"\n    if tight_layout:\n        plt.tight_layout()\n    plt.savefig(path, format=fig_extension, dpi=resolution)"
  },
  {
    "objectID": "blog5.html#the-normal-equation",
    "href": "blog5.html#the-normal-equation",
    "title": "Anomaly Detection",
    "section": "The Normal Equation",
    "text": "The Normal Equation\n\nimport numpy as np\n\nnp.random.seed(42)  # to make this code example reproducible\nm = 100  # number of instances\nX = 2 * np.random.rand(m, 1)  # column vector\ny = 4 + 3 * X + np.random.randn(m, 1)  # column vector\n\n\n# extra code – generates and saves Figure 4–1\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"generated_data_plot\")\nplt.show()\n\n\n\n\n\nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)  # add x0 = 1 to each instance\ntheta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n\n\ntheta_best\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\nX_new = np.array([[0], [2]])\nX_new_b = add_dummy_feature(X_new)  # add x0 = 1 to each instance\ny_predict = X_new_b @ theta_best\ny_predict\n\narray([[4.21509616],\n       [9.75532293]])\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\nplt.plot(X_new, y_predict, \"r-\", label=\"Predictions\")\nplt.plot(X, y, \"b.\")\n\n# extra code – beautifies and saves Figure 4–2\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nplt.legend(loc=\"upper left\")\nsave_fig(\"linear_model_predictions_plot\")\n\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\n\nlin_reg = LinearRegression()\nlin_reg.fit(X, y)\nlin_reg.intercept_, lin_reg.coef_\n\n(array([4.21509616]), array([[2.77011339]]))\n\n\n\nlin_reg.predict(X_new)\n\narray([[4.21509616],\n       [9.75532293]])\n\n\nThe LinearRegression class is based on the scipy.linalg.lstsq() function (the name stands for “least squares”), which you could call directly:\n\ntheta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=1e-6)\ntheta_best_svd\n\narray([[4.21509616],\n       [2.77011339]])\n\n\nThis function computes \\(\\mathbf{X}^+\\mathbf{y}\\), where \\(\\mathbf{X}^{+}\\) is the pseudoinverse of \\(\\mathbf{X}\\) (specifically the Moore-Penrose inverse). You can use np.linalg.pinv() to compute the pseudoinverse directly:\n\nnp.linalg.pinv(X_b) @ y\n\narray([[4.21509616],\n       [2.77011339]])"
  },
  {
    "objectID": "blog5.html#batch-gradient-descent",
    "href": "blog5.html#batch-gradient-descent",
    "title": "Anomaly Detection",
    "section": "Batch Gradient Descent",
    "text": "Batch Gradient Descent\n\neta = 0.1  # learning rate\nn_epochs = 1000\nm = len(X_b)  # number of instances\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # randomly initialized model parameters\n\nfor epoch in range(n_epochs):\n    gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n    theta = theta - eta * gradients\n\nThe trained model parameters:\n\ntheta\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\n# extra code – generates and saves Figure 4–8\n\nimport matplotlib as mpl\n\ndef plot_gradient_descent(theta, eta):\n    m = len(X_b)\n    plt.plot(X, y, \"b.\")\n    n_epochs = 1000\n    n_shown = 20\n    theta_path = []\n    for epoch in range(n_epochs):\n        if epoch &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(epoch / n_shown + 0.15))\n            plt.plot(X_new, y_predict, linestyle=\"solid\", color=color)\n        gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n        theta = theta - eta * gradients\n        theta_path.append(theta)\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 2, 0, 15])\n    plt.grid()\n    plt.title(fr\"$\\eta = {eta}$\")\n    return theta_path\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nplt.figure(figsize=(10, 4))\nplt.subplot(131)\nplot_gradient_descent(theta, eta=0.02)\nplt.ylabel(\"$y$\", rotation=0)\nplt.subplot(132)\ntheta_path_bgd = plot_gradient_descent(theta, eta=0.1)\nplt.gca().axes.yaxis.set_ticklabels([])\nplt.subplot(133)\nplt.gca().axes.yaxis.set_ticklabels([])\nplot_gradient_descent(theta, eta=0.5)\nsave_fig(\"gradient_descent_plot\")\nplt.show()"
  },
  {
    "objectID": "blog5.html#stochastic-gradient-descent",
    "href": "blog5.html#stochastic-gradient-descent",
    "title": "Anomaly Detection",
    "section": "Stochastic Gradient Descent",
    "text": "Stochastic Gradient Descent\n\ntheta_path_sgd = []  # extra code – we need to store the path of theta in the\n                     #              parameter space to plot the next figure\n\n\nn_epochs = 50\nt0, t1 = 5, 50  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nn_shown = 20  # extra code – just needed to generate the figure below\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\n\nfor epoch in range(n_epochs):\n    for iteration in range(m):\n\n        # extra code – these 4 lines are used to generate the figure\n        if epoch == 0 and iteration &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(iteration / n_shown + 0.15))\n            plt.plot(X_new, y_predict, color=color)\n\n        random_index = np.random.randint(m)\n        xi = X_b[random_index : random_index + 1]\n        yi = y[random_index : random_index + 1]\n        gradients = 2 * xi.T @ (xi @ theta - yi)  # for SGD, do not divide by m\n        eta = learning_schedule(epoch * m + iteration)\n        theta = theta - eta * gradients\n        theta_path_sgd.append(theta)  # extra code – to generate the figure\n\n# extra code – this section beautifies and saves Figure 4–10\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"sgd_plot\")\nplt.show()\n\n\n\n\n\ntheta\n\narray([[4.21076011],\n       [2.74856079]])\n\n\n\nfrom sklearn.linear_model import SGDRegressor\n\nsgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, penalty=None, eta0=0.01,\n                       n_iter_no_change=100, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\n\nSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SGDRegressorSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)\n\n\n\nsgd_reg.intercept_, sgd_reg.coef_\n\n(array([4.21278812]), array([2.77270267]))"
  },
  {
    "objectID": "blog5.html#mini-batch-gradient-descent",
    "href": "blog5.html#mini-batch-gradient-descent",
    "title": "Anomaly Detection",
    "section": "Mini-batch gradient descent",
    "text": "Mini-batch gradient descent\nThe code in this section is used to generate the next figure, it is not in the book.\n\n# extra code – this cell generates and saves Figure 4–11\n\nfrom math import ceil\n\nn_epochs = 50\nminibatch_size = 20\nn_batches_per_epoch = ceil(m / minibatch_size)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nt0, t1 = 200, 1000  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\ntheta_path_mgd = []\nfor epoch in range(n_epochs):\n    shuffled_indices = np.random.permutation(m)\n    X_b_shuffled = X_b[shuffled_indices]\n    y_shuffled = y[shuffled_indices]\n    for iteration in range(0, n_batches_per_epoch):\n        idx = iteration * minibatch_size\n        xi = X_b_shuffled[idx : idx + minibatch_size]\n        yi = y_shuffled[idx : idx + minibatch_size]\n        gradients = 2 / minibatch_size * xi.T @ (xi @ theta - yi)\n        eta = learning_schedule(iteration)\n        theta = theta - eta * gradients\n        theta_path_mgd.append(theta)\n\ntheta_path_bgd = np.array(theta_path_bgd)\ntheta_path_sgd = np.array(theta_path_sgd)\ntheta_path_mgd = np.array(theta_path_mgd)\n\nplt.figure(figsize=(7, 4))\nplt.plot(theta_path_sgd[:, 0], theta_path_sgd[:, 1], \"r-s\", linewidth=1,\n         label=\"Stochastic\")\nplt.plot(theta_path_mgd[:, 0], theta_path_mgd[:, 1], \"g-+\", linewidth=2,\n         label=\"Mini-batch\")\nplt.plot(theta_path_bgd[:, 0], theta_path_bgd[:, 1], \"b-o\", linewidth=3,\n         label=\"Batch\")\nplt.legend(loc=\"upper left\")\nplt.xlabel(r\"$\\theta_0$\")\nplt.ylabel(r\"$\\theta_1$   \", rotation=0)\nplt.axis([2.6, 4.6, 2.3, 3.4])\nplt.grid()\nsave_fig(\"gradient_descent_paths_plot\")\nplt.show()"
  },
  {
    "objectID": "blog5.html#ridge-regression",
    "href": "blog5.html#ridge-regression",
    "title": "Anomaly Detection",
    "section": "Ridge Regression",
    "text": "Ridge Regression\nLet’s generate a very small and noisy linear dataset:\n\n# extra code – we've done this type of generation several times before\nnp.random.seed(42)\nm = 20\nX = 3 * np.random.rand(m, 1)\ny = 1 + 0.5 * X + np.random.randn(m, 1) / 1.5\nX_new = np.linspace(0, 3, 100).reshape(100, 1)\n\n\n# extra code – a quick peek at the dataset we just generated\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \".\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$  \", rotation=0)\nplt.axis([0, 3, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import Ridge\n\nridge_reg = Ridge(alpha=0.1, solver=\"cholesky\")\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55325833]])\n\n\n\n# extra code – this cell generates and saves Figure 4–17\n\ndef plot_model(model_class, polynomial, alphas, **model_kwargs):\n    plt.plot(X, y, \"b.\", linewidth=3)\n    for alpha, style in zip(alphas, (\"b:\", \"g--\", \"r-\")):\n        if alpha &gt; 0:\n            model = model_class(alpha, **model_kwargs)\n        else:\n            model = LinearRegression()\n        if polynomial:\n            model = make_pipeline(\n                PolynomialFeatures(degree=10, include_bias=False),\n                StandardScaler(),\n                model)\n        model.fit(X, y)\n        y_new_regul = model.predict(X_new)\n        plt.plot(X_new, y_new_regul, style, linewidth=2,\n                 label=fr\"$\\alpha = {alpha}$\")\n    plt.legend(loc=\"upper left\")\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 3, 0, 3.5])\n    plt.grid()\n\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Ridge, polynomial=False, alphas=(0, 10, 100), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Ridge, polynomial=True, alphas=(0, 10**-5, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"ridge_regression_plot\")\nplt.show()\n\n\n\n\n\nsgd_reg = SGDRegressor(penalty=\"l2\", alpha=0.1 / m, tol=None,\n                       max_iter=1000, eta0=0.01, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\nsgd_reg.predict([[1.5]])\n\narray([1.55302613])\n\n\n\n# extra code – show that we get roughly the same solution as earlier when\n#              we use Stochastic Average GD (solver=\"sag\")\nridge_reg = Ridge(alpha=0.1, solver=\"sag\", random_state=42)\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55326019]])\n\n\n\n# extra code – shows the closed form solution of Ridge regression,\n#              compare with the next Ridge model's learned parameters below\nalpha = 0.1\nA = np.array([[0., 0.], [0., 1.]])\nX_b = np.c_[np.ones(m), X]\nnp.linalg.inv(X_b.T @ X_b + alpha * A) @ X_b.T @ y\n\narray([[0.97898394],\n       [0.3828496 ]])\n\n\n\nridge_reg.intercept_, ridge_reg.coef_  # extra code\n\n(array([0.97896386]), array([[0.38286422]]))"
  },
  {
    "objectID": "blog5.html#lasso-regression",
    "href": "blog5.html#lasso-regression",
    "title": "Anomaly Detection",
    "section": "Lasso Regression",
    "text": "Lasso Regression\n\nfrom sklearn.linear_model import Lasso\n\nlasso_reg = Lasso(alpha=0.1)\nlasso_reg.fit(X, y)\nlasso_reg.predict([[1.5]])\n\narray([1.53788174])\n\n\n\n# extra code – this cell generates and saves Figure 4–18\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Lasso, polynomial=False, alphas=(0, 0.1, 1), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Lasso, polynomial=True, alphas=(0, 1e-2, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"lasso_regression_plot\")\nplt.show()\n\n\n\n\n\n# extra code – this BIG cell generates and saves Figure 4–19\n\nt1a, t1b, t2a, t2b = -1, 3, -1.5, 1.5\n\nt1s = np.linspace(t1a, t1b, 500)\nt2s = np.linspace(t2a, t2b, 500)\nt1, t2 = np.meshgrid(t1s, t2s)\nT = np.c_[t1.ravel(), t2.ravel()]\nXr = np.array([[1, 1], [1, -1], [1, 0.5]])\nyr = 2 * Xr[:, :1] + 0.5 * Xr[:, 1:]\n\nJ = (1 / len(Xr) * ((T @ Xr.T - yr.T) ** 2).sum(axis=1)).reshape(t1.shape)\n\nN1 = np.linalg.norm(T, ord=1, axis=1).reshape(t1.shape)\nN2 = np.linalg.norm(T, ord=2, axis=1).reshape(t1.shape)\n\nt_min_idx = np.unravel_index(J.argmin(), J.shape)\nt1_min, t2_min = t1[t_min_idx], t2[t_min_idx]\n\nt_init = np.array([[0.25], [-1]])\n\ndef bgd_path(theta, X, y, l1, l2, core=1, eta=0.05, n_iterations=200):\n    path = [theta]\n    for iteration in range(n_iterations):\n        gradients = (core * 2 / len(X) * X.T @ (X @ theta - y)\n                     + l1 * np.sign(theta) + l2 * theta)\n        theta = theta - eta * gradients\n        path.append(theta)\n    return np.array(path)\n\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(10.1, 8))\n\nfor i, N, l1, l2, title in ((0, N1, 2.0, 0, \"Lasso\"), (1, N2, 0, 2.0, \"Ridge\")):\n    JR = J + l1 * N1 + l2 * 0.5 * N2 ** 2\n\n    tr_min_idx = np.unravel_index(JR.argmin(), JR.shape)\n    t1r_min, t2r_min = t1[tr_min_idx], t2[tr_min_idx]\n\n    levels = np.exp(np.linspace(0, 1, 20)) - 1\n    levelsJ = levels * (J.max() - J.min()) + J.min()\n    levelsJR = levels * (JR.max() - JR.min()) + JR.min()\n    levelsN = np.linspace(0, N.max(), 10)\n\n    path_J = bgd_path(t_init, Xr, yr, l1=0, l2=0)\n    path_JR = bgd_path(t_init, Xr, yr, l1, l2)\n    path_N = bgd_path(theta=np.array([[2.0], [0.5]]), X=Xr, y=yr,\n                      l1=np.sign(l1) / 3, l2=np.sign(l2), core=0)\n    ax = axes[i, 0]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, N / 2.0, levels=levelsN)\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.set_title(fr\"$\\ell_{i + 1}$ penalty\")\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n    ax.set_ylabel(r\"$\\theta_2$\", rotation=0)\n\n    ax = axes[i, 1]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, JR, levels=levelsJR, alpha=0.9)\n    ax.plot(path_JR[:, 0], path_JR[:, 1], \"w-o\")\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.plot(t1r_min, t2r_min, \"rs\")\n    ax.set_title(title)\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n\nsave_fig(\"lasso_vs_ridge_plot\")\nplt.show()"
  },
  {
    "objectID": "blog5.html#elastic-net",
    "href": "blog5.html#elastic-net",
    "title": "Anomaly Detection",
    "section": "Elastic Net",
    "text": "Elastic Net\n\nfrom sklearn.linear_model import ElasticNet\n\nelastic_net = ElasticNet(alpha=0.1, l1_ratio=0.5)\nelastic_net.fit(X, y)\nelastic_net.predict([[1.5]])\n\narray([1.54333232])"
  },
  {
    "objectID": "blog5.html#early-stopping",
    "href": "blog5.html#early-stopping",
    "title": "Anomaly Detection",
    "section": "Early Stopping",
    "text": "Early Stopping\nLet’s go back to the quadratic dataset we used earlier:\n\nfrom copy import deepcopy\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# extra code – creates the same quadratic dataset as earlier and splits it\nnp.random.seed(42)\nm = 100\nX = 6 * np.random.rand(m, 1) - 3\ny = 0.5 * X ** 2 + X + 2 + np.random.randn(m, 1)\nX_train, y_train = X[: m // 2], y[: m // 2, 0]\nX_valid, y_valid = X[m // 2 :], y[m // 2 :, 0]\n\npreprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False),\n                              StandardScaler())\nX_train_prep = preprocessing.fit_transform(X_train)\nX_valid_prep = preprocessing.transform(X_valid)\nsgd_reg = SGDRegressor(penalty=None, eta0=0.002, random_state=42)\nn_epochs = 500\nbest_valid_rmse = float('inf')\ntrain_errors, val_errors = [], []  # extra code – it's for the figure below\n\nfor epoch in range(n_epochs):\n    sgd_reg.partial_fit(X_train_prep, y_train)\n    y_valid_predict = sgd_reg.predict(X_valid_prep)\n    val_error = mean_squared_error(y_valid, y_valid_predict, squared=False)\n    if val_error &lt; best_valid_rmse:\n        best_valid_rmse = val_error\n        best_model = deepcopy(sgd_reg)\n\n    # extra code – we evaluate the train error and save it for the figure\n    y_train_predict = sgd_reg.predict(X_train_prep)\n    train_error = mean_squared_error(y_train, y_train_predict, squared=False)\n    val_errors.append(val_error)\n    train_errors.append(train_error)\n\n# extra code – this section generates and saves Figure 4–20\nbest_epoch = np.argmin(val_errors)\nplt.figure(figsize=(6, 4))\nplt.annotate('Best model',\n             xy=(best_epoch, best_valid_rmse),\n             xytext=(best_epoch, best_valid_rmse + 0.5),\n             ha=\"center\",\n             arrowprops=dict(facecolor='black', shrink=0.05))\nplt.plot([0, n_epochs], [best_valid_rmse, best_valid_rmse], \"k:\", linewidth=2)\nplt.plot(val_errors, \"b-\", linewidth=3, label=\"Validation set\")\nplt.plot(best_epoch, best_valid_rmse, \"bo\")\nplt.plot(train_errors, \"r--\", linewidth=2, label=\"Training set\")\nplt.legend(loc=\"upper right\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"RMSE\")\nplt.axis([0, n_epochs, 0, 3.5])\nplt.grid()\nsave_fig(\"early_stopping_plot\")\nplt.show()"
  },
  {
    "objectID": "blog5.html#estimating-probabilities",
    "href": "blog5.html#estimating-probabilities",
    "title": "Anomaly Detection",
    "section": "Estimating Probabilities",
    "text": "Estimating Probabilities\n\n# extra code – generates and saves Figure 4–21\n\nlim = 6\nt = np.linspace(-lim, lim, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.figure(figsize=(8, 3))\nplt.plot([-lim, lim], [0, 0], \"k-\")\nplt.plot([-lim, lim], [0.5, 0.5], \"k:\")\nplt.plot([-lim, lim], [1, 1], \"k:\")\nplt.plot([0, 0], [-1.1, 1.1], \"k-\")\nplt.plot(t, sig, \"b-\", linewidth=2, label=r\"$\\sigma(t) = \\dfrac{1}{1 + e^{-t}}$\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.axis([-lim, lim, -0.1, 1.1])\nplt.gca().set_yticks([0, 0.25, 0.5, 0.75, 1])\nplt.grid()\nsave_fig(\"logistic_function_plot\")\nplt.show()"
  },
  {
    "objectID": "blog5.html#decision-boundaries",
    "href": "blog5.html#decision-boundaries",
    "title": "Anomaly Detection",
    "section": "Decision Boundaries",
    "text": "Decision Boundaries\n\nfrom sklearn.datasets import load_iris\n\niris = load_iris(as_frame=True)\nlist(iris)\n\n['data',\n 'target',\n 'frame',\n 'target_names',\n 'DESCR',\n 'feature_names',\n 'filename',\n 'data_module']\n\n\n\nprint(iris.DESCR)  # extra code – it's a bit too long\n\n.. _iris_dataset:\n\nIris plants dataset\n--------------------\n\n**Data Set Characteristics:**\n\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n                \n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThe famous Iris database, first used by Sir R.A. Fisher. The dataset is taken\nfrom Fisher's paper. Note that it's the same as in R, but not as in the UCI\nMachine Learning Repository, which has two wrong data points.\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher's paper is a classic in the field and\nis referenced frequently to this day.  (See Duda & Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\n|details-start|\n**References**\n|details-split|\n\n- Fisher, R.A. \"The use of multiple measurements in taxonomic problems\"\n  Annual Eugenics, 7, Part II, 179-188 (1936); also in \"Contributions to\n  Mathematical Statistics\" (John Wiley, NY, 1950).\n- Duda, R.O., & Hart, P.E. (1973) Pattern Classification and Scene Analysis.\n  (Q327.D83) John Wiley & Sons.  ISBN 0-471-22361-1.  See page 218.\n- Dasarathy, B.V. (1980) \"Nosing Around the Neighborhood: A New System\n  Structure and Classification Rule for Recognition in Partially Exposed\n  Environments\".  IEEE Transactions on Pattern Analysis and Machine\n  Intelligence, Vol. PAMI-2, No. 1, 67-71.\n- Gates, G.W. (1972) \"The Reduced Nearest Neighbor Rule\".  IEEE Transactions\n  on Information Theory, May 1972, 431-433.\n- See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al\"s AUTOCLASS II\n  conceptual clustering system finds 3 classes in the data.\n- Many, many more ...\n\n|details-end|\n\n\n\niris.data.head(3)\n\n\n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n\n\n\n\n\n\niris.target.head(3)  # note that the instances are not shuffled\n\n0    0\n1    0\n2    0\nName: target, dtype: int64\n\n\n\niris.target_names\n\narray(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')\n\n\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\n\nX = iris.data[[\"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(random_state=42)\nlog_reg.fit(X_train, y_train)\n\nLogisticRegression(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=42)\n\n\n\nX_new = np.linspace(0, 3, 1000).reshape(-1, 1)  # reshape to get a column vector\ny_proba = log_reg.predict_proba(X_new)\ndecision_boundary = X_new[y_proba[:, 1] &gt;= 0.5][0, 0]\n\nplt.figure(figsize=(8, 3))  # extra code – not needed, just formatting\nplt.plot(X_new, y_proba[:, 0], \"b--\", linewidth=2,\n         label=\"Not Iris virginica proba\")\nplt.plot(X_new, y_proba[:, 1], \"g-\", linewidth=2, label=\"Iris virginica proba\")\nplt.plot([decision_boundary, decision_boundary], [0, 1], \"k:\", linewidth=2,\n         label=\"Decision boundary\")\n\n# extra code – this section beautifies and saves Figure 4–23\nplt.arrow(x=decision_boundary, y=0.08, dx=-0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"b\", ec=\"b\")\nplt.arrow(x=decision_boundary, y=0.92, dx=0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"g\", ec=\"g\")\nplt.plot(X_train[y_train == 0], y_train[y_train == 0], \"bs\")\nplt.plot(X_train[y_train == 1], y_train[y_train == 1], \"g^\")\nplt.xlabel(\"Petal width (cm)\")\nplt.ylabel(\"Probability\")\nplt.legend(loc=\"center left\")\nplt.axis([0, 3, -0.02, 1.02])\nplt.grid()\nsave_fig(\"logistic_regression_plot\")\n\nplt.show()\n\n\n\n\n\ndecision_boundary\n\n1.6516516516516517\n\n\n\nlog_reg.predict([[1.7], [1.5]])\n\narray([ True, False])\n\n\n\n# extra code – this cell generates and saves Figure 4–24\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(C=2, random_state=42)\nlog_reg.fit(X_train, y_train)\n\n# for the contour plot\nx0, x1 = np.meshgrid(np.linspace(2.9, 7, 500).reshape(-1, 1),\n                     np.linspace(0.8, 2.7, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]  # one instance per point on the figure\ny_proba = log_reg.predict_proba(X_new)\nzz = y_proba[:, 1].reshape(x0.shape)\n\n# for the decision boundary\nleft_right = np.array([2.9, 7])\nboundary = -((log_reg.coef_[0, 0] * left_right + log_reg.intercept_[0])\n             / log_reg.coef_[0, 1])\n\nplt.figure(figsize=(10, 4))\nplt.plot(X_train[y_train == 0, 0], X_train[y_train == 0, 1], \"bs\")\nplt.plot(X_train[y_train == 1, 0], X_train[y_train == 1, 1], \"g^\")\ncontour = plt.contour(x0, x1, zz, cmap=plt.cm.brg)\nplt.clabel(contour, inline=1)\nplt.plot(left_right, boundary, \"k--\", linewidth=3)\nplt.text(3.5, 1.27, \"Not Iris virginica\", color=\"b\", ha=\"center\")\nplt.text(6.5, 2.3, \"Iris virginica\", color=\"g\", ha=\"center\")\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.axis([2.9, 7, 0.8, 2.7])\nplt.grid()\nsave_fig(\"logistic_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog5.html#softmax-regression",
    "href": "blog5.html#softmax-regression",
    "title": "Anomaly Detection",
    "section": "Softmax Regression",
    "text": "Softmax Regression\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nsoftmax_reg = LogisticRegression(C=30, random_state=42)\nsoftmax_reg.fit(X_train, y_train)\n\nLogisticRegression(C=30, random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(C=30, random_state=42)\n\n\n\nsoftmax_reg.predict([[5, 2]])\n\narray([2])\n\n\n\nsoftmax_reg.predict_proba([[5, 2]]).round(2)\n\narray([[0.  , 0.04, 0.96]])\n\n\n\n# extra code – this cell generates and saves Figure 4–25\n\nfrom matplotlib.colors import ListedColormap\n\ncustom_cmap = ListedColormap([\"#fafab0\", \"#9898ff\", \"#a0faa0\"])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\n\ny_proba = softmax_reg.predict_proba(X_new)\ny_predict = softmax_reg.predict(X_new)\n\nzz1 = y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"center left\")\nplt.axis([0.5, 7, 0, 3.5])\nplt.grid()\nsave_fig(\"softmax_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog5.html#to-11.",
    "href": "blog5.html#to-11.",
    "title": "Anomaly Detection",
    "section": "1. to 11.",
    "text": "1. to 11.\n\nIf you have a training set with millions of features you can use Stochastic Gradient Descent or Mini-batch Gradient Descent, and perhaps Batch Gradient Descent if the training set fits in memory. But you cannot use the Normal Equation or the SVD approach because the computational complexity grows quickly (more than quadratically) with the number of features.\nIf the features in your training set have very different scales, the cost function will have the shape of an elongated bowl, so the Gradient Descent algorithms will take a long time to converge. To solve this you should scale the data before training the model. Note that the Normal Equation or SVD approach will work just fine without scaling. Moreover, regularized models may converge to a suboptimal solution if the features are not scaled: since regularization penalizes large weights, features with smaller values will tend to be ignored compared to features with larger values.\nGradient Descent cannot get stuck in a local minimum when training a Logistic Regression model because the cost function is convex. Convex means that if you draw a straight line between any two points on the curve, the line never crosses the curve.\nIf the optimization problem is convex (such as Linear Regression or Logistic Regression), and assuming the learning rate is not too high, then all Gradient Descent algorithms will approach the global optimum and end up producing fairly similar models. However, unless you gradually reduce the learning rate, Stochastic GD and Mini-batch GD will never truly converge; instead, they will keep jumping back and forth around the global optimum. This means that even if you let them run for a very long time, these Gradient Descent algorithms will produce slightly different models.\nIf the validation error consistently goes up after every epoch, then one possibility is that the learning rate is too high and the algorithm is diverging. If the training error also goes up, then this is clearly the problem and you should reduce the learning rate. However, if the training error is not going up, then your model is overfitting the training set and you should stop training.\nDue to their random nature, neither Stochastic Gradient Descent nor Mini-batch Gradient Descent is guaranteed to make progress at every single training iteration. So if you immediately stop training when the validation error goes up, you may stop much too early, before the optimum is reached. A better option is to save the model at regular intervals; then, when it has not improved for a long time (meaning it will probably never beat the record), you can revert to the best saved model.\nStochastic Gradient Descent has the fastest training iteration since it considers only one training instance at a time, so it is generally the first to reach the vicinity of the global optimum (or Mini-batch GD with a very small mini-batch size). However, only Batch Gradient Descent will actually converge, given enough training time. As mentioned, Stochastic GD and Mini-batch GD will bounce around the optimum, unless you gradually reduce the learning rate.\nIf the validation error is much higher than the training error, this is likely because your model is overfitting the training set. One way to try to fix this is to reduce the polynomial degree: a model with fewer degrees of freedom is less likely to overfit. Another thing you can try is to regularize the model—for example, by adding an ℓ₂ penalty (Ridge) or an ℓ₁ penalty (Lasso) to the cost function. This will also reduce the degrees of freedom of the model. Lastly, you can try to increase the size of the training set.\nIf both the training error and the validation error are almost equal and fairly high, the model is likely underfitting the training set, which means it has a high bias. You should try reducing the regularization hyperparameter α.\nLet’s see:\n\n\nA model with some regularization typically performs better than a model without any regularization, so you should generally prefer Ridge Regression over plain Linear Regression.\nLasso Regression uses an ℓ₁ penalty, which tends to push the weights down to exactly zero. This leads to sparse models, where all weights are zero except for the most important weights. This is a way to perform feature selection automatically, which is good if you suspect that only a few features actually matter. When you are not sure, you should prefer Ridge Regression.\nElastic Net is generally preferred over Lasso since Lasso may behave erratically in some cases (when several features are strongly correlated or when there are more features than training instances). However, it does add an extra hyperparameter to tune. If you want Lasso without the erratic behavior, you can just use Elastic Net with an l1_ratio close to 1.\n\n\nIf you want to classify pictures as outdoor/indoor and daytime/nighttime, since these are not exclusive classes (i.e., all four combinations are possible) you should train two Logistic Regression classifiers."
  },
  {
    "objectID": "blog5.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "href": "blog5.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "title": "Anomaly Detection",
    "section": "12. Batch Gradient Descent with early stopping for Softmax Regression",
    "text": "12. Batch Gradient Descent with early stopping for Softmax Regression\nExercise: Implement Batch Gradient Descent with early stopping for Softmax Regression without using Scikit-Learn, only NumPy. Use it on a classification task such as the iris dataset.\nLet’s start by loading the data. We will just reuse the Iris dataset we loaded earlier.\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"].values\n\nWe need to add the bias term for every instance (\\(x_0 = 1\\)). The easiest option to do this would be to use Scikit-Learn’s add_dummy_feature() function, but the point of this exercise is to get a better understanding of the algorithms by implementing them manually. So here is one possible implementation:\n\nX_with_bias = np.c_[np.ones(len(X)), X]\n\nThe easiest option to split the dataset into a training set, a validation set and a test set would be to use Scikit-Learn’s train_test_split() function, but again, we want to do it manually:\n\ntest_ratio = 0.2\nvalidation_ratio = 0.2\ntotal_size = len(X_with_bias)\n\ntest_size = int(total_size * test_ratio)\nvalidation_size = int(total_size * validation_ratio)\ntrain_size = total_size - test_size - validation_size\n\nnp.random.seed(42)\nrnd_indices = np.random.permutation(total_size)\n\nX_train = X_with_bias[rnd_indices[:train_size]]\ny_train = y[rnd_indices[:train_size]]\nX_valid = X_with_bias[rnd_indices[train_size:-test_size]]\ny_valid = y[rnd_indices[train_size:-test_size]]\nX_test = X_with_bias[rnd_indices[-test_size:]]\ny_test = y[rnd_indices[-test_size:]]\n\nThe targets are currently class indices (0, 1 or 2), but we need target class probabilities to train the Softmax Regression model. Each instance will have target class probabilities equal to 0.0 for all classes except for the target class which will have a probability of 1.0 (in other words, the vector of class probabilities for any given instance is a one-hot vector). Let’s write a small function to convert the vector of class indices into a matrix containing a one-hot vector for each instance. To understand this code, you need to know that np.diag(np.ones(n)) creates an n×n matrix full of 0s except for 1s on the main diagonal. Moreover, if a is a NumPy array, then a[[1, 3, 2]] returns an array with 3 rows equal to a[1], a[3] and a[2] (this is advanced NumPy indexing).\n\ndef to_one_hot(y):\n    return np.diag(np.ones(y.max() + 1))[y]\n\nLet’s test this function on the first 10 instances:\n\ny_train[:10]\n\narray([1, 0, 2, 1, 1, 0, 1, 2, 1, 1])\n\n\n\nto_one_hot(y_train[:10])\n\narray([[0., 1., 0.],\n       [1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.],\n       [1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.]])\n\n\nLooks good, so let’s create the target class probabilities matrix for the training set and the test set:\n\nY_train_one_hot = to_one_hot(y_train)\nY_valid_one_hot = to_one_hot(y_valid)\nY_test_one_hot = to_one_hot(y_test)\n\nNow let’s scale the inputs. We compute the mean and standard deviation of each feature on the training set (except for the bias feature), then we center and scale each feature in the training set, the validation set, and the test set:\n\nmean = X_train[:, 1:].mean(axis=0)\nstd = X_train[:, 1:].std(axis=0)\nX_train[:, 1:] = (X_train[:, 1:] - mean) / std\nX_valid[:, 1:] = (X_valid[:, 1:] - mean) / std\nX_test[:, 1:] = (X_test[:, 1:] - mean) / std\n\nNow let’s implement the Softmax function. Recall that it is defined by the following equation:\n\\(\\sigma\\left(\\mathbf{s}(\\mathbf{x})\\right)_k = \\dfrac{\\exp\\left(s_k(\\mathbf{x})\\right)}{\\sum\\limits_{j=1}^{K}{\\exp\\left(s_j(\\mathbf{x})\\right)}}\\)\n\ndef softmax(logits):\n    exps = np.exp(logits)\n    exp_sums = exps.sum(axis=1, keepdims=True)\n    return exps / exp_sums\n\nWe are almost ready to start training. Let’s define the number of inputs and outputs:\n\nn_inputs = X_train.shape[1]  # == 3 (2 features plus the bias term)\nn_outputs = len(np.unique(y_train))  # == 3 (there are 3 iris classes)\n\nNow here comes the hardest part: training! Theoretically, it’s simple: it’s just a matter of translating the math equations into Python code. But in practice, it can be quite tricky: in particular, it’s easy to mix up the order of the terms, or the indices. You can even end up with code that looks like it’s working but is actually not computing exactly the right thing. When unsure, you should write down the shape of each term in the equation and make sure the corresponding terms in your code match closely. It can also help to evaluate each term independently and print them out. The good news it that you won’t have to do this everyday, since all this is well implemented by Scikit-Learn, but it will help you understand what’s going on under the hood.\nSo the equations we will need are the cost function:\n\\(J(\\mathbf{\\Theta}) = - \\dfrac{1}{m}\\sum\\limits_{i=1}^{m}\\sum\\limits_{k=1}^{K}{y_k^{(i)}\\log\\left(\\hat{p}_k^{(i)}\\right)}\\)\nAnd the equation for the gradients:\n\\(\\nabla_{\\mathbf{\\theta}^{(k)}} \\, J(\\mathbf{\\Theta}) = \\dfrac{1}{m} \\sum\\limits_{i=1}^{m}{ \\left ( \\hat{p}^{(i)}_k - y_k^{(i)} \\right ) \\mathbf{x}^{(i)}}\\)\nNote that \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) may not be computable if \\(\\hat{p}_k^{(i)} = 0\\). So we will add a tiny value \\(\\epsilon\\) to \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) to avoid getting nan values.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        print(epoch, xentropy_losses.sum(axis=1).mean())\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    Theta = Theta - eta * gradients\n\n0 3.7085808486476917\n1000 0.14519367480830647\n2000 0.13013095755040877\n3000 0.12009639326384532\n4000 0.11372961364786878\n5000 0.11002459532472424\n\n\nAnd that’s it! The Softmax model is trained. Let’s look at the model parameters:\n\nTheta\n\narray([[ 0.41931626,  6.11112089, -5.52429876],\n       [-6.53054533, -0.74608616,  8.33137102],\n       [-5.28115784,  0.25152675,  6.90680425]])\n\n\nLet’s make predictions for the validation set and check the accuracy score:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nWell, this model looks pretty ok. For the sake of the exercise, let’s add a bit of \\(\\ell_2\\) regularization. The following training code is similar to the one above, but the loss now has an additional \\(\\ell_2\\) penalty, and the gradients have the proper additional term (note that we don’t regularize the first element of Theta since this corresponds to the bias term). Also, let’s try increasing the learning rate eta.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\nalpha = 0.01  # regularization hyperparameter\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n        total_loss = xentropy_losses.sum(axis=1).mean() + alpha * l2_loss\n        print(epoch, total_loss.round(4))\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n1000 0.3259\n2000 0.3259\n3000 0.3259\n4000 0.3259\n5000 0.3259\n\n\nBecause of the additional \\(\\ell_2\\) penalty, the loss seems greater than earlier, but perhaps this model will perform better? Let’s find out:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nIn this case, the \\(\\ell_2\\) penalty did not change the test accuracy. Perhaps try fine-tuning alpha?\nNow let’s add early stopping. For this we just need to measure the loss on the validation set at every iteration and stop when the error starts growing.\n\neta = 0.5\nn_epochs = 50_001\nm = len(X_train)\nepsilon = 1e-5\nC = 100  # regularization hyperparameter\nbest_loss = np.infty\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    Y_proba_valid = softmax(X_valid @ Theta)\n    xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n    l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n    total_loss = xentropy_losses.sum(axis=1).mean() + 1 / C * l2_loss\n    if epoch % 1000 == 0:\n        print(epoch, total_loss.round(4))\n    if total_loss &lt; best_loss:\n        best_loss = total_loss\n    else:\n        print(epoch - 1, best_loss.round(4))\n        print(epoch, total_loss.round(4), \"early stopping!\")\n        break\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), 1 / C * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n281 0.3256\n282 0.3256 early stopping!\n\n\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nOh well, still no change in validation accuracy, but at least early stopping shortened training a bit.\nNow let’s plot the model’s predictions on the whole dataset (remember to scale all features fed to the model):\n\ncustom_cmap = mpl.colors.ListedColormap(['#fafab0', '#9898ff', '#a0faa0'])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\nX_new = (X_new - mean) / std\nX_new_with_bias = np.c_[np.ones(len(X_new)), X_new]\n\nlogits = X_new_with_bias @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\nzz1 = Y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"upper left\")\nplt.axis([0, 7, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\nAnd now let’s measure the final model’s accuracy on the test set:\n\nlogits = X_test @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_test).mean()\naccuracy_score\n\n0.9666666666666667\n\n\nWell we get even better performance on the test set. This variability is likely due to the very small size of the dataset: depending on how you sample the training set, validation set and the test set, you can get quite different results. Try changing the random seed and running the code again a few times, you will see that the results will vary."
  },
  {
    "objectID": "blog0.html",
    "href": "blog0.html",
    "title": "Clustering",
    "section": "",
    "text": "Chapter 4 – Training Models\nThis notebook contains all the sample code and solutions to the exercises in chapter 4.\nThis project requires Python 3.7 or above:\nimport sys\n\nassert sys.version_info &gt;= (3, 7)\nIt also requires Scikit-Learn ≥ 1.0.1:\nfrom packaging import version\nimport sklearn\n\nassert version.parse(sklearn.__version__) &gt;= version.parse(\"1.0.1\")\nAs we did in previous chapters, let’s define the default font sizes to make the figures prettier:\nimport matplotlib.pyplot as plt\n\nplt.rc('font', size=14)\nplt.rc('axes', labelsize=14, titlesize=14)\nplt.rc('legend', fontsize=14)\nplt.rc('xtick', labelsize=10)\nplt.rc('ytick', labelsize=10)\nAnd let’s create the images/training_linear_models folder (if it doesn’t already exist), and define the save_fig() function which is used through this notebook to save the figures in high-res for the book:\nfrom pathlib import Path\n\nIMAGES_PATH = Path() / \"images\" / \"training_linear_models\"\nIMAGES_PATH.mkdir(parents=True, exist_ok=True)\n\ndef save_fig(fig_id, tight_layout=True, fig_extension=\"png\", resolution=300):\n    path = IMAGES_PATH / f\"{fig_id}.{fig_extension}\"\n    if tight_layout:\n        plt.tight_layout()\n    plt.savefig(path, format=fig_extension, dpi=resolution)"
  },
  {
    "objectID": "blog0.html#the-normal-equation",
    "href": "blog0.html#the-normal-equation",
    "title": "Clustering",
    "section": "The Normal Equation",
    "text": "The Normal Equation\n\nimport numpy as np\n\nnp.random.seed(42)  # to make this code example reproducible\nm = 100  # number of instances\nX = 2 * np.random.rand(m, 1)  # column vector\ny = 4 + 3 * X + np.random.randn(m, 1)  # column vector\n\n\n# extra code – generates and saves Figure 4–1\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"generated_data_plot\")\nplt.show()\n\n\n\n\n\nfrom sklearn.preprocessing import add_dummy_feature\n\nX_b = add_dummy_feature(X)  # add x0 = 1 to each instance\ntheta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n\n\ntheta_best\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\nX_new = np.array([[0], [2]])\nX_new_b = add_dummy_feature(X_new)  # add x0 = 1 to each instance\ny_predict = X_new_b @ theta_best\ny_predict\n\narray([[4.21509616],\n       [9.75532293]])\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\nplt.plot(X_new, y_predict, \"r-\", label=\"Predictions\")\nplt.plot(X, y, \"b.\")\n\n# extra code – beautifies and saves Figure 4–2\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nplt.legend(loc=\"upper left\")\nsave_fig(\"linear_model_predictions_plot\")\n\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\n\nlin_reg = LinearRegression()\nlin_reg.fit(X, y)\nlin_reg.intercept_, lin_reg.coef_\n\n(array([4.21509616]), array([[2.77011339]]))\n\n\n\nlin_reg.predict(X_new)\n\narray([[4.21509616],\n       [9.75532293]])\n\n\nThe LinearRegression class is based on the scipy.linalg.lstsq() function (the name stands for “least squares”), which you could call directly:\n\ntheta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=1e-6)\ntheta_best_svd\n\narray([[4.21509616],\n       [2.77011339]])\n\n\nThis function computes \\(\\mathbf{X}^+\\mathbf{y}\\), where \\(\\mathbf{X}^{+}\\) is the pseudoinverse of \\(\\mathbf{X}\\) (specifically the Moore-Penrose inverse). You can use np.linalg.pinv() to compute the pseudoinverse directly:\n\nnp.linalg.pinv(X_b) @ y\n\narray([[4.21509616],\n       [2.77011339]])"
  },
  {
    "objectID": "blog0.html#batch-gradient-descent",
    "href": "blog0.html#batch-gradient-descent",
    "title": "Clustering",
    "section": "Batch Gradient Descent",
    "text": "Batch Gradient Descent\n\neta = 0.1  # learning rate\nn_epochs = 1000\nm = len(X_b)  # number of instances\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # randomly initialized model parameters\n\nfor epoch in range(n_epochs):\n    gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n    theta = theta - eta * gradients\n\nThe trained model parameters:\n\ntheta\n\narray([[4.21509616],\n       [2.77011339]])\n\n\n\n# extra code – generates and saves Figure 4–8\n\nimport matplotlib as mpl\n\ndef plot_gradient_descent(theta, eta):\n    m = len(X_b)\n    plt.plot(X, y, \"b.\")\n    n_epochs = 1000\n    n_shown = 20\n    theta_path = []\n    for epoch in range(n_epochs):\n        if epoch &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(epoch / n_shown + 0.15))\n            plt.plot(X_new, y_predict, linestyle=\"solid\", color=color)\n        gradients = 2 / m * X_b.T @ (X_b @ theta - y)\n        theta = theta - eta * gradients\n        theta_path.append(theta)\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 2, 0, 15])\n    plt.grid()\n    plt.title(fr\"$\\eta = {eta}$\")\n    return theta_path\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nplt.figure(figsize=(10, 4))\nplt.subplot(131)\nplot_gradient_descent(theta, eta=0.02)\nplt.ylabel(\"$y$\", rotation=0)\nplt.subplot(132)\ntheta_path_bgd = plot_gradient_descent(theta, eta=0.1)\nplt.gca().axes.yaxis.set_ticklabels([])\nplt.subplot(133)\nplt.gca().axes.yaxis.set_ticklabels([])\nplot_gradient_descent(theta, eta=0.5)\nsave_fig(\"gradient_descent_plot\")\nplt.show()"
  },
  {
    "objectID": "blog0.html#stochastic-gradient-descent",
    "href": "blog0.html#stochastic-gradient-descent",
    "title": "Clustering",
    "section": "Stochastic Gradient Descent",
    "text": "Stochastic Gradient Descent\n\ntheta_path_sgd = []  # extra code – we need to store the path of theta in the\n                     #              parameter space to plot the next figure\n\n\nn_epochs = 50\nt0, t1 = 5, 50  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nn_shown = 20  # extra code – just needed to generate the figure below\nplt.figure(figsize=(6, 4))  # extra code – not needed, just formatting\n\nfor epoch in range(n_epochs):\n    for iteration in range(m):\n\n        # extra code – these 4 lines are used to generate the figure\n        if epoch == 0 and iteration &lt; n_shown:\n            y_predict = X_new_b @ theta\n            color = mpl.colors.rgb2hex(plt.cm.OrRd(iteration / n_shown + 0.15))\n            plt.plot(X_new, y_predict, color=color)\n\n        random_index = np.random.randint(m)\n        xi = X_b[random_index : random_index + 1]\n        yi = y[random_index : random_index + 1]\n        gradients = 2 * xi.T @ (xi @ theta - yi)  # for SGD, do not divide by m\n        eta = learning_schedule(epoch * m + iteration)\n        theta = theta - eta * gradients\n        theta_path_sgd.append(theta)  # extra code – to generate the figure\n\n# extra code – this section beautifies and saves Figure 4–10\nplt.plot(X, y, \"b.\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$\", rotation=0)\nplt.axis([0, 2, 0, 15])\nplt.grid()\nsave_fig(\"sgd_plot\")\nplt.show()\n\n\n\n\n\ntheta\n\narray([[4.21076011],\n       [2.74856079]])\n\n\n\nfrom sklearn.linear_model import SGDRegressor\n\nsgd_reg = SGDRegressor(max_iter=1000, tol=1e-5, penalty=None, eta0=0.01,\n                       n_iter_no_change=100, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\n\nSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SGDRegressorSGDRegressor(n_iter_no_change=100, penalty=None, random_state=42, tol=1e-05)\n\n\n\nsgd_reg.intercept_, sgd_reg.coef_\n\n(array([4.21278812]), array([2.77270267]))"
  },
  {
    "objectID": "blog0.html#mini-batch-gradient-descent",
    "href": "blog0.html#mini-batch-gradient-descent",
    "title": "Clustering",
    "section": "Mini-batch gradient descent",
    "text": "Mini-batch gradient descent\nThe code in this section is used to generate the next figure, it is not in the book.\n\n# extra code – this cell generates and saves Figure 4–11\n\nfrom math import ceil\n\nn_epochs = 50\nminibatch_size = 20\nn_batches_per_epoch = ceil(m / minibatch_size)\n\nnp.random.seed(42)\ntheta = np.random.randn(2, 1)  # random initialization\n\nt0, t1 = 200, 1000  # learning schedule hyperparameters\n\ndef learning_schedule(t):\n    return t0 / (t + t1)\n\ntheta_path_mgd = []\nfor epoch in range(n_epochs):\n    shuffled_indices = np.random.permutation(m)\n    X_b_shuffled = X_b[shuffled_indices]\n    y_shuffled = y[shuffled_indices]\n    for iteration in range(0, n_batches_per_epoch):\n        idx = iteration * minibatch_size\n        xi = X_b_shuffled[idx : idx + minibatch_size]\n        yi = y_shuffled[idx : idx + minibatch_size]\n        gradients = 2 / minibatch_size * xi.T @ (xi @ theta - yi)\n        eta = learning_schedule(iteration)\n        theta = theta - eta * gradients\n        theta_path_mgd.append(theta)\n\ntheta_path_bgd = np.array(theta_path_bgd)\ntheta_path_sgd = np.array(theta_path_sgd)\ntheta_path_mgd = np.array(theta_path_mgd)\n\nplt.figure(figsize=(7, 4))\nplt.plot(theta_path_sgd[:, 0], theta_path_sgd[:, 1], \"r-s\", linewidth=1,\n         label=\"Stochastic\")\nplt.plot(theta_path_mgd[:, 0], theta_path_mgd[:, 1], \"g-+\", linewidth=2,\n         label=\"Mini-batch\")\nplt.plot(theta_path_bgd[:, 0], theta_path_bgd[:, 1], \"b-o\", linewidth=3,\n         label=\"Batch\")\nplt.legend(loc=\"upper left\")\nplt.xlabel(r\"$\\theta_0$\")\nplt.ylabel(r\"$\\theta_1$   \", rotation=0)\nplt.axis([2.6, 4.6, 2.3, 3.4])\nplt.grid()\nsave_fig(\"gradient_descent_paths_plot\")\nplt.show()"
  },
  {
    "objectID": "blog0.html#ridge-regression",
    "href": "blog0.html#ridge-regression",
    "title": "Clustering",
    "section": "Ridge Regression",
    "text": "Ridge Regression\nLet’s generate a very small and noisy linear dataset:\n\n# extra code – we've done this type of generation several times before\nnp.random.seed(42)\nm = 20\nX = 3 * np.random.rand(m, 1)\ny = 1 + 0.5 * X + np.random.randn(m, 1) / 1.5\nX_new = np.linspace(0, 3, 100).reshape(100, 1)\n\n\n# extra code – a quick peek at the dataset we just generated\nplt.figure(figsize=(6, 4))\nplt.plot(X, y, \".\")\nplt.xlabel(\"$x_1$\")\nplt.ylabel(\"$y$  \", rotation=0)\nplt.axis([0, 3, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\n\nfrom sklearn.linear_model import Ridge\n\nridge_reg = Ridge(alpha=0.1, solver=\"cholesky\")\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55325833]])\n\n\n\n# extra code – this cell generates and saves Figure 4–17\n\ndef plot_model(model_class, polynomial, alphas, **model_kwargs):\n    plt.plot(X, y, \"b.\", linewidth=3)\n    for alpha, style in zip(alphas, (\"b:\", \"g--\", \"r-\")):\n        if alpha &gt; 0:\n            model = model_class(alpha, **model_kwargs)\n        else:\n            model = LinearRegression()\n        if polynomial:\n            model = make_pipeline(\n                PolynomialFeatures(degree=10, include_bias=False),\n                StandardScaler(),\n                model)\n        model.fit(X, y)\n        y_new_regul = model.predict(X_new)\n        plt.plot(X_new, y_new_regul, style, linewidth=2,\n                 label=fr\"$\\alpha = {alpha}$\")\n    plt.legend(loc=\"upper left\")\n    plt.xlabel(\"$x_1$\")\n    plt.axis([0, 3, 0, 3.5])\n    plt.grid()\n\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Ridge, polynomial=False, alphas=(0, 10, 100), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Ridge, polynomial=True, alphas=(0, 10**-5, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"ridge_regression_plot\")\nplt.show()\n\n\n\n\n\nsgd_reg = SGDRegressor(penalty=\"l2\", alpha=0.1 / m, tol=None,\n                       max_iter=1000, eta0=0.01, random_state=42)\nsgd_reg.fit(X, y.ravel())  # y.ravel() because fit() expects 1D targets\nsgd_reg.predict([[1.5]])\n\narray([1.55302613])\n\n\n\n# extra code – show that we get roughly the same solution as earlier when\n#              we use Stochastic Average GD (solver=\"sag\")\nridge_reg = Ridge(alpha=0.1, solver=\"sag\", random_state=42)\nridge_reg.fit(X, y)\nridge_reg.predict([[1.5]])\n\narray([[1.55326019]])\n\n\n\n# extra code – shows the closed form solution of Ridge regression,\n#              compare with the next Ridge model's learned parameters below\nalpha = 0.1\nA = np.array([[0., 0.], [0., 1.]])\nX_b = np.c_[np.ones(m), X]\nnp.linalg.inv(X_b.T @ X_b + alpha * A) @ X_b.T @ y\n\narray([[0.97898394],\n       [0.3828496 ]])\n\n\n\nridge_reg.intercept_, ridge_reg.coef_  # extra code\n\n(array([0.97896386]), array([[0.38286422]]))"
  },
  {
    "objectID": "blog0.html#lasso-regression",
    "href": "blog0.html#lasso-regression",
    "title": "Clustering",
    "section": "Lasso Regression",
    "text": "Lasso Regression\n\nfrom sklearn.linear_model import Lasso\n\nlasso_reg = Lasso(alpha=0.1)\nlasso_reg.fit(X, y)\nlasso_reg.predict([[1.5]])\n\narray([1.53788174])\n\n\n\n# extra code – this cell generates and saves Figure 4–18\nplt.figure(figsize=(9, 3.5))\nplt.subplot(121)\nplot_model(Lasso, polynomial=False, alphas=(0, 0.1, 1), random_state=42)\nplt.ylabel(\"$y$  \", rotation=0)\nplt.subplot(122)\nplot_model(Lasso, polynomial=True, alphas=(0, 1e-2, 1), random_state=42)\nplt.gca().axes.yaxis.set_ticklabels([])\nsave_fig(\"lasso_regression_plot\")\nplt.show()\n\n\n\n\n\n# extra code – this BIG cell generates and saves Figure 4–19\n\nt1a, t1b, t2a, t2b = -1, 3, -1.5, 1.5\n\nt1s = np.linspace(t1a, t1b, 500)\nt2s = np.linspace(t2a, t2b, 500)\nt1, t2 = np.meshgrid(t1s, t2s)\nT = np.c_[t1.ravel(), t2.ravel()]\nXr = np.array([[1, 1], [1, -1], [1, 0.5]])\nyr = 2 * Xr[:, :1] + 0.5 * Xr[:, 1:]\n\nJ = (1 / len(Xr) * ((T @ Xr.T - yr.T) ** 2).sum(axis=1)).reshape(t1.shape)\n\nN1 = np.linalg.norm(T, ord=1, axis=1).reshape(t1.shape)\nN2 = np.linalg.norm(T, ord=2, axis=1).reshape(t1.shape)\n\nt_min_idx = np.unravel_index(J.argmin(), J.shape)\nt1_min, t2_min = t1[t_min_idx], t2[t_min_idx]\n\nt_init = np.array([[0.25], [-1]])\n\ndef bgd_path(theta, X, y, l1, l2, core=1, eta=0.05, n_iterations=200):\n    path = [theta]\n    for iteration in range(n_iterations):\n        gradients = (core * 2 / len(X) * X.T @ (X @ theta - y)\n                     + l1 * np.sign(theta) + l2 * theta)\n        theta = theta - eta * gradients\n        path.append(theta)\n    return np.array(path)\n\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(10.1, 8))\n\nfor i, N, l1, l2, title in ((0, N1, 2.0, 0, \"Lasso\"), (1, N2, 0, 2.0, \"Ridge\")):\n    JR = J + l1 * N1 + l2 * 0.5 * N2 ** 2\n\n    tr_min_idx = np.unravel_index(JR.argmin(), JR.shape)\n    t1r_min, t2r_min = t1[tr_min_idx], t2[tr_min_idx]\n\n    levels = np.exp(np.linspace(0, 1, 20)) - 1\n    levelsJ = levels * (J.max() - J.min()) + J.min()\n    levelsJR = levels * (JR.max() - JR.min()) + JR.min()\n    levelsN = np.linspace(0, N.max(), 10)\n\n    path_J = bgd_path(t_init, Xr, yr, l1=0, l2=0)\n    path_JR = bgd_path(t_init, Xr, yr, l1, l2)\n    path_N = bgd_path(theta=np.array([[2.0], [0.5]]), X=Xr, y=yr,\n                      l1=np.sign(l1) / 3, l2=np.sign(l2), core=0)\n    ax = axes[i, 0]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, N / 2.0, levels=levelsN)\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.set_title(fr\"$\\ell_{i + 1}$ penalty\")\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n    ax.set_ylabel(r\"$\\theta_2$\", rotation=0)\n\n    ax = axes[i, 1]\n    ax.grid()\n    ax.axhline(y=0, color=\"k\")\n    ax.axvline(x=0, color=\"k\")\n    ax.contourf(t1, t2, JR, levels=levelsJR, alpha=0.9)\n    ax.plot(path_JR[:, 0], path_JR[:, 1], \"w-o\")\n    ax.plot(path_N[:, 0], path_N[:, 1], \"y--\")\n    ax.plot(0, 0, \"ys\")\n    ax.plot(t1_min, t2_min, \"ys\")\n    ax.plot(t1r_min, t2r_min, \"rs\")\n    ax.set_title(title)\n    ax.axis([t1a, t1b, t2a, t2b])\n    if i == 1:\n        ax.set_xlabel(r\"$\\theta_1$\")\n\nsave_fig(\"lasso_vs_ridge_plot\")\nplt.show()"
  },
  {
    "objectID": "blog0.html#elastic-net",
    "href": "blog0.html#elastic-net",
    "title": "Clustering",
    "section": "Elastic Net",
    "text": "Elastic Net\n\nfrom sklearn.linear_model import ElasticNet\n\nelastic_net = ElasticNet(alpha=0.1, l1_ratio=0.5)\nelastic_net.fit(X, y)\nelastic_net.predict([[1.5]])\n\narray([1.54333232])"
  },
  {
    "objectID": "blog0.html#early-stopping",
    "href": "blog0.html#early-stopping",
    "title": "Clustering",
    "section": "Early Stopping",
    "text": "Early Stopping\nLet’s go back to the quadratic dataset we used earlier:\n\nfrom copy import deepcopy\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# extra code – creates the same quadratic dataset as earlier and splits it\nnp.random.seed(42)\nm = 100\nX = 6 * np.random.rand(m, 1) - 3\ny = 0.5 * X ** 2 + X + 2 + np.random.randn(m, 1)\nX_train, y_train = X[: m // 2], y[: m // 2, 0]\nX_valid, y_valid = X[m // 2 :], y[m // 2 :, 0]\n\npreprocessing = make_pipeline(PolynomialFeatures(degree=90, include_bias=False),\n                              StandardScaler())\nX_train_prep = preprocessing.fit_transform(X_train)\nX_valid_prep = preprocessing.transform(X_valid)\nsgd_reg = SGDRegressor(penalty=None, eta0=0.002, random_state=42)\nn_epochs = 500\nbest_valid_rmse = float('inf')\ntrain_errors, val_errors = [], []  # extra code – it's for the figure below\n\nfor epoch in range(n_epochs):\n    sgd_reg.partial_fit(X_train_prep, y_train)\n    y_valid_predict = sgd_reg.predict(X_valid_prep)\n    val_error = mean_squared_error(y_valid, y_valid_predict, squared=False)\n    if val_error &lt; best_valid_rmse:\n        best_valid_rmse = val_error\n        best_model = deepcopy(sgd_reg)\n\n    # extra code – we evaluate the train error and save it for the figure\n    y_train_predict = sgd_reg.predict(X_train_prep)\n    train_error = mean_squared_error(y_train, y_train_predict, squared=False)\n    val_errors.append(val_error)\n    train_errors.append(train_error)\n\n# extra code – this section generates and saves Figure 4–20\nbest_epoch = np.argmin(val_errors)\nplt.figure(figsize=(6, 4))\nplt.annotate('Best model',\n             xy=(best_epoch, best_valid_rmse),\n             xytext=(best_epoch, best_valid_rmse + 0.5),\n             ha=\"center\",\n             arrowprops=dict(facecolor='black', shrink=0.05))\nplt.plot([0, n_epochs], [best_valid_rmse, best_valid_rmse], \"k:\", linewidth=2)\nplt.plot(val_errors, \"b-\", linewidth=3, label=\"Validation set\")\nplt.plot(best_epoch, best_valid_rmse, \"bo\")\nplt.plot(train_errors, \"r--\", linewidth=2, label=\"Training set\")\nplt.legend(loc=\"upper right\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"RMSE\")\nplt.axis([0, n_epochs, 0, 3.5])\nplt.grid()\nsave_fig(\"early_stopping_plot\")\nplt.show()"
  },
  {
    "objectID": "blog0.html#estimating-probabilities",
    "href": "blog0.html#estimating-probabilities",
    "title": "Clustering",
    "section": "Estimating Probabilities",
    "text": "Estimating Probabilities\n\n# extra code – generates and saves Figure 4–21\n\nlim = 6\nt = np.linspace(-lim, lim, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.figure(figsize=(8, 3))\nplt.plot([-lim, lim], [0, 0], \"k-\")\nplt.plot([-lim, lim], [0.5, 0.5], \"k:\")\nplt.plot([-lim, lim], [1, 1], \"k:\")\nplt.plot([0, 0], [-1.1, 1.1], \"k-\")\nplt.plot(t, sig, \"b-\", linewidth=2, label=r\"$\\sigma(t) = \\dfrac{1}{1 + e^{-t}}$\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.axis([-lim, lim, -0.1, 1.1])\nplt.gca().set_yticks([0, 0.25, 0.5, 0.75, 1])\nplt.grid()\nsave_fig(\"logistic_function_plot\")\nplt.show()"
  },
  {
    "objectID": "blog0.html#decision-boundaries",
    "href": "blog0.html#decision-boundaries",
    "title": "Clustering",
    "section": "Decision Boundaries",
    "text": "Decision Boundaries\n\nfrom sklearn.datasets import load_iris\n\niris = load_iris(as_frame=True)\nlist(iris)\n\n['data',\n 'target',\n 'frame',\n 'target_names',\n 'DESCR',\n 'feature_names',\n 'filename',\n 'data_module']\n\n\n\nprint(iris.DESCR)  # extra code – it's a bit too long\n\n.. _iris_dataset:\n\nIris plants dataset\n--------------------\n\n**Data Set Characteristics:**\n\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n                \n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThe famous Iris database, first used by Sir R.A. Fisher. The dataset is taken\nfrom Fisher's paper. Note that it's the same as in R, but not as in the UCI\nMachine Learning Repository, which has two wrong data points.\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher's paper is a classic in the field and\nis referenced frequently to this day.  (See Duda & Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\n|details-start|\n**References**\n|details-split|\n\n- Fisher, R.A. \"The use of multiple measurements in taxonomic problems\"\n  Annual Eugenics, 7, Part II, 179-188 (1936); also in \"Contributions to\n  Mathematical Statistics\" (John Wiley, NY, 1950).\n- Duda, R.O., & Hart, P.E. (1973) Pattern Classification and Scene Analysis.\n  (Q327.D83) John Wiley & Sons.  ISBN 0-471-22361-1.  See page 218.\n- Dasarathy, B.V. (1980) \"Nosing Around the Neighborhood: A New System\n  Structure and Classification Rule for Recognition in Partially Exposed\n  Environments\".  IEEE Transactions on Pattern Analysis and Machine\n  Intelligence, Vol. PAMI-2, No. 1, 67-71.\n- Gates, G.W. (1972) \"The Reduced Nearest Neighbor Rule\".  IEEE Transactions\n  on Information Theory, May 1972, 431-433.\n- See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al\"s AUTOCLASS II\n  conceptual clustering system finds 3 classes in the data.\n- Many, many more ...\n\n|details-end|\n\n\n\niris.data.head(3)\n\n\n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n\n\n\n\n\n\niris.target.head(3)  # note that the instances are not shuffled\n\n0    0\n1    0\n2    0\nName: target, dtype: int64\n\n\n\niris.target_names\n\narray(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')\n\n\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\n\nX = iris.data[[\"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(random_state=42)\nlog_reg.fit(X_train, y_train)\n\nLogisticRegression(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=42)\n\n\n\nX_new = np.linspace(0, 3, 1000).reshape(-1, 1)  # reshape to get a column vector\ny_proba = log_reg.predict_proba(X_new)\ndecision_boundary = X_new[y_proba[:, 1] &gt;= 0.5][0, 0]\n\nplt.figure(figsize=(8, 3))  # extra code – not needed, just formatting\nplt.plot(X_new, y_proba[:, 0], \"b--\", linewidth=2,\n         label=\"Not Iris virginica proba\")\nplt.plot(X_new, y_proba[:, 1], \"g-\", linewidth=2, label=\"Iris virginica proba\")\nplt.plot([decision_boundary, decision_boundary], [0, 1], \"k:\", linewidth=2,\n         label=\"Decision boundary\")\n\n# extra code – this section beautifies and saves Figure 4–23\nplt.arrow(x=decision_boundary, y=0.08, dx=-0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"b\", ec=\"b\")\nplt.arrow(x=decision_boundary, y=0.92, dx=0.3, dy=0,\n          head_width=0.05, head_length=0.1, fc=\"g\", ec=\"g\")\nplt.plot(X_train[y_train == 0], y_train[y_train == 0], \"bs\")\nplt.plot(X_train[y_train == 1], y_train[y_train == 1], \"g^\")\nplt.xlabel(\"Petal width (cm)\")\nplt.ylabel(\"Probability\")\nplt.legend(loc=\"center left\")\nplt.axis([0, 3, -0.02, 1.02])\nplt.grid()\nsave_fig(\"logistic_regression_plot\")\n\nplt.show()\n\n\n\n\n\ndecision_boundary\n\n1.6516516516516517\n\n\n\nlog_reg.predict([[1.7], [1.5]])\n\narray([ True, False])\n\n\n\n# extra code – this cell generates and saves Figure 4–24\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris.target_names[iris.target] == 'virginica'\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nlog_reg = LogisticRegression(C=2, random_state=42)\nlog_reg.fit(X_train, y_train)\n\n# for the contour plot\nx0, x1 = np.meshgrid(np.linspace(2.9, 7, 500).reshape(-1, 1),\n                     np.linspace(0.8, 2.7, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]  # one instance per point on the figure\ny_proba = log_reg.predict_proba(X_new)\nzz = y_proba[:, 1].reshape(x0.shape)\n\n# for the decision boundary\nleft_right = np.array([2.9, 7])\nboundary = -((log_reg.coef_[0, 0] * left_right + log_reg.intercept_[0])\n             / log_reg.coef_[0, 1])\n\nplt.figure(figsize=(10, 4))\nplt.plot(X_train[y_train == 0, 0], X_train[y_train == 0, 1], \"bs\")\nplt.plot(X_train[y_train == 1, 0], X_train[y_train == 1, 1], \"g^\")\ncontour = plt.contour(x0, x1, zz, cmap=plt.cm.brg)\nplt.clabel(contour, inline=1)\nplt.plot(left_right, boundary, \"k--\", linewidth=3)\nplt.text(3.5, 1.27, \"Not Iris virginica\", color=\"b\", ha=\"center\")\nplt.text(6.5, 2.3, \"Iris virginica\", color=\"g\", ha=\"center\")\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.axis([2.9, 7, 0.8, 2.7])\nplt.grid()\nsave_fig(\"logistic_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog0.html#softmax-regression",
    "href": "blog0.html#softmax-regression",
    "title": "Clustering",
    "section": "Softmax Regression",
    "text": "Softmax Regression\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nsoftmax_reg = LogisticRegression(C=30, random_state=42)\nsoftmax_reg.fit(X_train, y_train)\n\nLogisticRegression(C=30, random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(C=30, random_state=42)\n\n\n\nsoftmax_reg.predict([[5, 2]])\n\narray([2])\n\n\n\nsoftmax_reg.predict_proba([[5, 2]]).round(2)\n\narray([[0.  , 0.04, 0.96]])\n\n\n\n# extra code – this cell generates and saves Figure 4–25\n\nfrom matplotlib.colors import ListedColormap\n\ncustom_cmap = ListedColormap([\"#fafab0\", \"#9898ff\", \"#a0faa0\"])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\n\ny_proba = softmax_reg.predict_proba(X_new)\ny_predict = softmax_reg.predict(X_new)\n\nzz1 = y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"center left\")\nplt.axis([0.5, 7, 0, 3.5])\nplt.grid()\nsave_fig(\"softmax_regression_contour_plot\")\nplt.show()"
  },
  {
    "objectID": "blog0.html#to-11.",
    "href": "blog0.html#to-11.",
    "title": "Clustering",
    "section": "1. to 11.",
    "text": "1. to 11.\n\nIf you have a training set with millions of features you can use Stochastic Gradient Descent or Mini-batch Gradient Descent, and perhaps Batch Gradient Descent if the training set fits in memory. But you cannot use the Normal Equation or the SVD approach because the computational complexity grows quickly (more than quadratically) with the number of features.\nIf the features in your training set have very different scales, the cost function will have the shape of an elongated bowl, so the Gradient Descent algorithms will take a long time to converge. To solve this you should scale the data before training the model. Note that the Normal Equation or SVD approach will work just fine without scaling. Moreover, regularized models may converge to a suboptimal solution if the features are not scaled: since regularization penalizes large weights, features with smaller values will tend to be ignored compared to features with larger values.\nGradient Descent cannot get stuck in a local minimum when training a Logistic Regression model because the cost function is convex. Convex means that if you draw a straight line between any two points on the curve, the line never crosses the curve.\nIf the optimization problem is convex (such as Linear Regression or Logistic Regression), and assuming the learning rate is not too high, then all Gradient Descent algorithms will approach the global optimum and end up producing fairly similar models. However, unless you gradually reduce the learning rate, Stochastic GD and Mini-batch GD will never truly converge; instead, they will keep jumping back and forth around the global optimum. This means that even if you let them run for a very long time, these Gradient Descent algorithms will produce slightly different models.\nIf the validation error consistently goes up after every epoch, then one possibility is that the learning rate is too high and the algorithm is diverging. If the training error also goes up, then this is clearly the problem and you should reduce the learning rate. However, if the training error is not going up, then your model is overfitting the training set and you should stop training.\nDue to their random nature, neither Stochastic Gradient Descent nor Mini-batch Gradient Descent is guaranteed to make progress at every single training iteration. So if you immediately stop training when the validation error goes up, you may stop much too early, before the optimum is reached. A better option is to save the model at regular intervals; then, when it has not improved for a long time (meaning it will probably never beat the record), you can revert to the best saved model.\nStochastic Gradient Descent has the fastest training iteration since it considers only one training instance at a time, so it is generally the first to reach the vicinity of the global optimum (or Mini-batch GD with a very small mini-batch size). However, only Batch Gradient Descent will actually converge, given enough training time. As mentioned, Stochastic GD and Mini-batch GD will bounce around the optimum, unless you gradually reduce the learning rate.\nIf the validation error is much higher than the training error, this is likely because your model is overfitting the training set. One way to try to fix this is to reduce the polynomial degree: a model with fewer degrees of freedom is less likely to overfit. Another thing you can try is to regularize the model—for example, by adding an ℓ₂ penalty (Ridge) or an ℓ₁ penalty (Lasso) to the cost function. This will also reduce the degrees of freedom of the model. Lastly, you can try to increase the size of the training set.\nIf both the training error and the validation error are almost equal and fairly high, the model is likely underfitting the training set, which means it has a high bias. You should try reducing the regularization hyperparameter α.\nLet’s see:\n\n\nA model with some regularization typically performs better than a model without any regularization, so you should generally prefer Ridge Regression over plain Linear Regression.\nLasso Regression uses an ℓ₁ penalty, which tends to push the weights down to exactly zero. This leads to sparse models, where all weights are zero except for the most important weights. This is a way to perform feature selection automatically, which is good if you suspect that only a few features actually matter. When you are not sure, you should prefer Ridge Regression.\nElastic Net is generally preferred over Lasso since Lasso may behave erratically in some cases (when several features are strongly correlated or when there are more features than training instances). However, it does add an extra hyperparameter to tune. If you want Lasso without the erratic behavior, you can just use Elastic Net with an l1_ratio close to 1.\n\n\nIf you want to classify pictures as outdoor/indoor and daytime/nighttime, since these are not exclusive classes (i.e., all four combinations are possible) you should train two Logistic Regression classifiers."
  },
  {
    "objectID": "blog0.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "href": "blog0.html#batch-gradient-descent-with-early-stopping-for-softmax-regression",
    "title": "Clustering",
    "section": "12. Batch Gradient Descent with early stopping for Softmax Regression",
    "text": "12. Batch Gradient Descent with early stopping for Softmax Regression\nExercise: Implement Batch Gradient Descent with early stopping for Softmax Regression without using Scikit-Learn, only NumPy. Use it on a classification task such as the iris dataset.\nLet’s start by loading the data. We will just reuse the Iris dataset we loaded earlier.\n\nX = iris.data[[\"petal length (cm)\", \"petal width (cm)\"]].values\ny = iris[\"target\"].values\n\nWe need to add the bias term for every instance (\\(x_0 = 1\\)). The easiest option to do this would be to use Scikit-Learn’s add_dummy_feature() function, but the point of this exercise is to get a better understanding of the algorithms by implementing them manually. So here is one possible implementation:\n\nX_with_bias = np.c_[np.ones(len(X)), X]\n\nThe easiest option to split the dataset into a training set, a validation set and a test set would be to use Scikit-Learn’s train_test_split() function, but again, we want to do it manually:\n\ntest_ratio = 0.2\nvalidation_ratio = 0.2\ntotal_size = len(X_with_bias)\n\ntest_size = int(total_size * test_ratio)\nvalidation_size = int(total_size * validation_ratio)\ntrain_size = total_size - test_size - validation_size\n\nnp.random.seed(42)\nrnd_indices = np.random.permutation(total_size)\n\nX_train = X_with_bias[rnd_indices[:train_size]]\ny_train = y[rnd_indices[:train_size]]\nX_valid = X_with_bias[rnd_indices[train_size:-test_size]]\ny_valid = y[rnd_indices[train_size:-test_size]]\nX_test = X_with_bias[rnd_indices[-test_size:]]\ny_test = y[rnd_indices[-test_size:]]\n\nThe targets are currently class indices (0, 1 or 2), but we need target class probabilities to train the Softmax Regression model. Each instance will have target class probabilities equal to 0.0 for all classes except for the target class which will have a probability of 1.0 (in other words, the vector of class probabilities for any given instance is a one-hot vector). Let’s write a small function to convert the vector of class indices into a matrix containing a one-hot vector for each instance. To understand this code, you need to know that np.diag(np.ones(n)) creates an n×n matrix full of 0s except for 1s on the main diagonal. Moreover, if a is a NumPy array, then a[[1, 3, 2]] returns an array with 3 rows equal to a[1], a[3] and a[2] (this is advanced NumPy indexing).\n\ndef to_one_hot(y):\n    return np.diag(np.ones(y.max() + 1))[y]\n\nLet’s test this function on the first 10 instances:\n\ny_train[:10]\n\narray([1, 0, 2, 1, 1, 0, 1, 2, 1, 1])\n\n\n\nto_one_hot(y_train[:10])\n\narray([[0., 1., 0.],\n       [1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.],\n       [1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.],\n       [0., 1., 0.]])\n\n\nLooks good, so let’s create the target class probabilities matrix for the training set and the test set:\n\nY_train_one_hot = to_one_hot(y_train)\nY_valid_one_hot = to_one_hot(y_valid)\nY_test_one_hot = to_one_hot(y_test)\n\nNow let’s scale the inputs. We compute the mean and standard deviation of each feature on the training set (except for the bias feature), then we center and scale each feature in the training set, the validation set, and the test set:\n\nmean = X_train[:, 1:].mean(axis=0)\nstd = X_train[:, 1:].std(axis=0)\nX_train[:, 1:] = (X_train[:, 1:] - mean) / std\nX_valid[:, 1:] = (X_valid[:, 1:] - mean) / std\nX_test[:, 1:] = (X_test[:, 1:] - mean) / std\n\nNow let’s implement the Softmax function. Recall that it is defined by the following equation:\n\\(\\sigma\\left(\\mathbf{s}(\\mathbf{x})\\right)_k = \\dfrac{\\exp\\left(s_k(\\mathbf{x})\\right)}{\\sum\\limits_{j=1}^{K}{\\exp\\left(s_j(\\mathbf{x})\\right)}}\\)\n\ndef softmax(logits):\n    exps = np.exp(logits)\n    exp_sums = exps.sum(axis=1, keepdims=True)\n    return exps / exp_sums\n\nWe are almost ready to start training. Let’s define the number of inputs and outputs:\n\nn_inputs = X_train.shape[1]  # == 3 (2 features plus the bias term)\nn_outputs = len(np.unique(y_train))  # == 3 (there are 3 iris classes)\n\nNow here comes the hardest part: training! Theoretically, it’s simple: it’s just a matter of translating the math equations into Python code. But in practice, it can be quite tricky: in particular, it’s easy to mix up the order of the terms, or the indices. You can even end up with code that looks like it’s working but is actually not computing exactly the right thing. When unsure, you should write down the shape of each term in the equation and make sure the corresponding terms in your code match closely. It can also help to evaluate each term independently and print them out. The good news it that you won’t have to do this everyday, since all this is well implemented by Scikit-Learn, but it will help you understand what’s going on under the hood.\nSo the equations we will need are the cost function:\n\\(J(\\mathbf{\\Theta}) = - \\dfrac{1}{m}\\sum\\limits_{i=1}^{m}\\sum\\limits_{k=1}^{K}{y_k^{(i)}\\log\\left(\\hat{p}_k^{(i)}\\right)}\\)\nAnd the equation for the gradients:\n\\(\\nabla_{\\mathbf{\\theta}^{(k)}} \\, J(\\mathbf{\\Theta}) = \\dfrac{1}{m} \\sum\\limits_{i=1}^{m}{ \\left ( \\hat{p}^{(i)}_k - y_k^{(i)} \\right ) \\mathbf{x}^{(i)}}\\)\nNote that \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) may not be computable if \\(\\hat{p}_k^{(i)} = 0\\). So we will add a tiny value \\(\\epsilon\\) to \\(\\log\\left(\\hat{p}_k^{(i)}\\right)\\) to avoid getting nan values.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        print(epoch, xentropy_losses.sum(axis=1).mean())\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    Theta = Theta - eta * gradients\n\n0 3.7085808486476917\n1000 0.14519367480830647\n2000 0.13013095755040877\n3000 0.12009639326384532\n4000 0.11372961364786878\n5000 0.11002459532472424\n\n\nAnd that’s it! The Softmax model is trained. Let’s look at the model parameters:\n\nTheta\n\narray([[ 0.41931626,  6.11112089, -5.52429876],\n       [-6.53054533, -0.74608616,  8.33137102],\n       [-5.28115784,  0.25152675,  6.90680425]])\n\n\nLet’s make predictions for the validation set and check the accuracy score:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nWell, this model looks pretty ok. For the sake of the exercise, let’s add a bit of \\(\\ell_2\\) regularization. The following training code is similar to the one above, but the loss now has an additional \\(\\ell_2\\) penalty, and the gradients have the proper additional term (note that we don’t regularize the first element of Theta since this corresponds to the bias term). Also, let’s try increasing the learning rate eta.\n\neta = 0.5\nn_epochs = 5001\nm = len(X_train)\nepsilon = 1e-5\nalpha = 0.01  # regularization hyperparameter\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    if epoch % 1000 == 0:\n        Y_proba_valid = softmax(X_valid @ Theta)\n        xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n        l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n        total_loss = xentropy_losses.sum(axis=1).mean() + alpha * l2_loss\n        print(epoch, total_loss.round(4))\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n1000 0.3259\n2000 0.3259\n3000 0.3259\n4000 0.3259\n5000 0.3259\n\n\nBecause of the additional \\(\\ell_2\\) penalty, the loss seems greater than earlier, but perhaps this model will perform better? Let’s find out:\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nIn this case, the \\(\\ell_2\\) penalty did not change the test accuracy. Perhaps try fine-tuning alpha?\nNow let’s add early stopping. For this we just need to measure the loss on the validation set at every iteration and stop when the error starts growing.\n\neta = 0.5\nn_epochs = 50_001\nm = len(X_train)\nepsilon = 1e-5\nC = 100  # regularization hyperparameter\nbest_loss = np.infty\n\nnp.random.seed(42)\nTheta = np.random.randn(n_inputs, n_outputs)\n\nfor epoch in range(n_epochs):\n    logits = X_train @ Theta\n    Y_proba = softmax(logits)\n    Y_proba_valid = softmax(X_valid @ Theta)\n    xentropy_losses = -(Y_valid_one_hot * np.log(Y_proba_valid + epsilon))\n    l2_loss = 1 / 2 * (Theta[1:] ** 2).sum()\n    total_loss = xentropy_losses.sum(axis=1).mean() + 1 / C * l2_loss\n    if epoch % 1000 == 0:\n        print(epoch, total_loss.round(4))\n    if total_loss &lt; best_loss:\n        best_loss = total_loss\n    else:\n        print(epoch - 1, best_loss.round(4))\n        print(epoch, total_loss.round(4), \"early stopping!\")\n        break\n    error = Y_proba - Y_train_one_hot\n    gradients = 1 / m * X_train.T @ error\n    gradients += np.r_[np.zeros([1, n_outputs]), 1 / C * Theta[1:]]\n    Theta = Theta - eta * gradients\n\n0 3.7372\n281 0.3256\n282 0.3256 early stopping!\n\n\n\nlogits = X_valid @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_valid).mean()\naccuracy_score\n\n0.9333333333333333\n\n\nOh well, still no change in validation accuracy, but at least early stopping shortened training a bit.\nNow let’s plot the model’s predictions on the whole dataset (remember to scale all features fed to the model):\n\ncustom_cmap = mpl.colors.ListedColormap(['#fafab0', '#9898ff', '#a0faa0'])\n\nx0, x1 = np.meshgrid(np.linspace(0, 8, 500).reshape(-1, 1),\n                     np.linspace(0, 3.5, 200).reshape(-1, 1))\nX_new = np.c_[x0.ravel(), x1.ravel()]\nX_new = (X_new - mean) / std\nX_new_with_bias = np.c_[np.ones(len(X_new)), X_new]\n\nlogits = X_new_with_bias @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\nzz1 = Y_proba[:, 1].reshape(x0.shape)\nzz = y_predict.reshape(x0.shape)\n\nplt.figure(figsize=(10, 4))\nplt.plot(X[y == 2, 0], X[y == 2, 1], \"g^\", label=\"Iris virginica\")\nplt.plot(X[y == 1, 0], X[y == 1, 1], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y == 0, 0], X[y == 0, 1], \"yo\", label=\"Iris setosa\")\n\nplt.contourf(x0, x1, zz, cmap=custom_cmap)\ncontour = plt.contour(x0, x1, zz1, cmap=\"hot\")\nplt.clabel(contour, inline=1)\nplt.xlabel(\"Petal length\")\nplt.ylabel(\"Petal width\")\nplt.legend(loc=\"upper left\")\nplt.axis([0, 7, 0, 3.5])\nplt.grid()\nplt.show()\n\n\n\n\nAnd now let’s measure the final model’s accuracy on the test set:\n\nlogits = X_test @ Theta\nY_proba = softmax(logits)\ny_predict = Y_proba.argmax(axis=1)\n\naccuracy_score = (y_predict == y_test).mean()\naccuracy_score\n\n0.9666666666666667\n\n\nWell we get even better performance on the test set. This variability is likely due to the very small size of the dataset: depending on how you sample the training set, validation set and the test set, you can get quite different results. Try changing the random seed and running the code again a few times, you will see that the results will vary."
  },
  {
    "objectID": "about.html#key-probability-rules",
    "href": "about.html#key-probability-rules",
    "title": "Probability Theory and Random Variables",
    "section": "Key Probability Rules",
    "text": "Key Probability Rules\n1. Probability of any Event: The probability of an event A in the sample space S, P(A) cannot be negative or more than 1. The probability of all the events in the sample space S adds to 1.\n        P(A) ≥ 0\n\n        P(A) ≤ 1\n\n        P(S) = 1\n2. Addition Rule: The addition rule is a fundamental concept that deals with the probability of the union of two or more events. For two events A and B, the probability of their union (A ∪ B) is given by:\n        P(A ∪ B) = P(A) + P(B) − P(A ∩ B)\nThis formula accounts for the overlap between events A and B to avoid double-counting. The probability of the intersection P(A∩B) is subtracted to ensure accuracy.\n3. Bayes Rule: The multiplication rule governs the probability of the intersection of two events. For two events A and B, the probability of their intersection (A∩B) is given by:\n        P(A ∩ B) = P(A)⋅P(B∣A)\nHere, P(B∣A) represents the conditional probability of event B occurring given that event A has occurred. It expresses the probability of B within the context of A.\n4. Independence Rule: Two events, A and B, are considered independent if the occurrence (or non-occurrence) of one event has no influence on the probability of the other event.\n        P(A ∩ B) = P(A)⋅P(B)\n\n        P(A∣B) = P(A) and P(B∣A) = P(B)\nThese fundamental probability rules lay the groundwork for more complex probability calculations, enabling us to analyze and predict the likelihood of various outcomes in uncertain scenarios. They are essential tools for decision-making and risk assessment in diverse fields, from statistics to finance and beyond."
  },
  {
    "objectID": "about.html#types-of-probability",
    "href": "about.html#types-of-probability",
    "title": "Probability Theory and Random Variables",
    "section": "Types of Probability",
    "text": "Types of Probability\nProbability comes in various forms, each serving a specific purpose in different contexts. Here are three types of probability: classical, empirical, and subjective, along with real-world examples to illustrate each:\nClassical Probability\nClassical probability is based on equally likely outcomes in a sample space. It assumes that each outcome in the sample space is equally likely to occur.\nExample: Consider a fair coin. The sample space is {Heads, Tails}, and since the coin is fair, each outcome is equally likely. The probability of getting Heads or Tails is 0.5 or 50%.\nEmpircal Probability\nEmpirical probability is based on observed data. It involves calculating the probability of an event by analyzing data collected from actual experiments or observations.\nExample: Suppose you want to know the probability of rain in a particular city. Empirical probability would involve collecting data over time, noting the days with rain, and calculating the ratio of rainy days to the total number of days. If it rained on 30 out of 90 days, the empirical probability would be 0.333 or approximately 33.3%.\nSubjective Probability\nSubjective probability is based on personal judgment, beliefs, or opinions. It reflects an individual’s subjective assessment of the likelihood of an event.\nExample: A doctor might assign a subjective probability to the likelihood of a patient having a particular illness based on their experience, knowledge, and the patient’s symptoms. This probability is subjective and varies from one medical professional to another."
  },
  {
    "objectID": "about.html#probability-distributions",
    "href": "about.html#probability-distributions",
    "title": "Probability Theory and Random Variables",
    "section": "Probability Distributions",
    "text": "Probability Distributions\nIn probability theory, a probability distribution describes the likelihood of various outcomes in a sample space. It provides a way to model and analyze uncertainty by assigning probabilities to different events. Probability distributions are fundamental tools in probability theory, offering insights into the nature of random variables and helping us make predictions about their behavior. Probability distributions help quantify the uncertainty associated with different outcomes of a random variable. They provide a systematic way to express the likelihood of each possible value.\nProbability distributions form the basis for statistical inference. They allow us to make predictions about the population based on a sample and make informed decisions under uncertainty. Probability distributions are used to model various random processes in diverse fields such as physics, finance, biology, and engineering. They provide a mathematical framework to describe the probabilistic nature of real-world phenomena.\nUniform Distribution\nThe uniform distribution is characterized by all outcomes being equally likely. Each value within a specified range has the same probability of occurring. The probability density function (PDF) for a continuous uniform distribution over the interval [a,b] is given by:\n        f(x)= 1/b−a  for a ≤ x ≤ b\nConsider the example of rolling a fair six-sided die. Each face of the die has an equal chance of landing face up. If we assume the die is unbiased, the outcome of each roll follows a uniform distribution over the discrete values {1,2,3,4,5,6}. Each number has a probability of 1/6 of occurring.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import uniform\n\n# Define the range [a, b]\na = 1\nb = 6\n\n# Generate a sample of 1000 values from a uniform distribution\nsample = uniform.rvs(loc=a, scale=b-a, size=1000)\n\n# Plot the histogram of the sample\nplt.hist(sample, bins=20, density=True, alpha=0.7, color='blue')\n\n# Plot the probability density function (PDF)\nx = np.linspace(a, b, 100)\nplt.plot(x, uniform.pdf(x, loc=a, scale=b-a), 'r-', lw=2, label='Uniform PDF')\n\n# Add labels and a legend\nplt.xlabel('Outcome')\nplt.ylabel('Probability Density')\nplt.title('Uniform Distribution Example')\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\nBinomial Distribution\nThe binomial distribution models the number of successes in a fixed number of independent and identically distributed Bernoulli trials, where each trial has only two possible outcomes (usually termed as “success” and “failure”). The probability mass function (PMF) of a binomial distribution is given by:\n         P(X=k)=( n_p_k ) p^k (1-p)^(n-k)\n​ where: n is the number of trials, k is the number of successes, p is the probability of success on a single trial, and (1−p) is the probability of failure on a single trial.\nConsider the example of flipping a biased coin. Let’s say you have a coin that has a 60% chance of landing heads (success) and a 40% chance of landing tails (failure). If you flip this coin 5 times, you can model the number of heads obtained using a binomial distribution.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import binom\n\n# Define parameters\nn_trials = 5  # Number of coin flips\np_success = 0.6  # Probability of getting heads\n\n# Generate possible outcomes (0 to n_trials)\nx = np.arange(0, n_trials+1)\n\n# Calculate binomial probabilities for each outcome\nbinomial_pmf = binom.pmf(x, n_trials, p_success)\n\n# Plot the probability mass function (PMF)\nplt.stem(x, binomial_pmf, basefmt='b-', linefmt='b-', markerfmt='bo')\nplt.title('Binomial Distribution Example')\nplt.xlabel('Number of Heads')\nplt.ylabel('Probability')\nplt.show()\n\n\n\n\nGaussian Distribution\nThe Gaussian distribution, also known as the normal distribution, is a continuous probability distribution that is symmetric around its mean. It is characterized by its bell-shaped curve. The probability density function (PDF) of a normal distribution is given by:\nf(x;μ,σ)= 1/σroot(2π) e -1/3(x-mu)/sigma^2\nwhere: μ is the mean, σ is the standard deviation\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# Define parameters\nmean_height = 170  # Mean height in centimeters\nstd_deviation = 10  # Standard deviation in centimeters\n\n# Generate a sample of 1000 values from a normal distribution\nsample = np.random.normal(mean_height, std_deviation, 1000)\n\n# Plot the histogram of the sample\nplt.hist(sample, bins=30, density=True, alpha=0.7, color='blue')\n\n# Plot the probability density function (PDF)\nx = np.linspace(mean_height - 4*std_deviation, mean_height + 4*std_deviation, 100)\nplt.plot(x, norm.pdf(x, mean_height, std_deviation), 'r-', lw=2, label='Normal PDF')\n\n# Add labels and a legend\nplt.xlabel('Height (cm)')\nplt.ylabel('Probability Density')\nplt.title('Gaussian Distribution Example')\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\nPoisson Distribution\nThe Poisson distribution models the number of events that occur in a fixed interval of time or space. It is often used for rare events with a known average rate of occurrence. The probability mass function (PMF) of a Poisson distribution is given by:\nInsert formula\nInsert defining elements\nConsider a scenario where you are observing the number of customer arrivals at a store in a given hour, and you know that, on average, 5 customers arrive per hour. The Poisson distribution can be used to model the probability of observing a specific number of customer arrivals in that hour.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import poisson\n\n# Define parameter\naverage_rate = 5  # Average number of events per interval\n\n# Generate possible outcomes (0 to 20 events)\nx = np.arange(0, 21)\n\n# Calculate Poisson probabilities for each outcome\npoisson_pmf = poisson.pmf(x, average_rate)\n\n# Plot the probability mass function (PMF)\nplt.stem(x, poisson_pmf, basefmt='b-', linefmt='b-', markerfmt='bo')\nplt.title('Poisson Distribution Example')\nplt.xlabel('Number of Events')\nplt.ylabel('Probability')\nplt.show()\n\n\n\n\nExponential Distribution\nThe exponential distribution models the time between events in a Poisson process, where events occur continuously and independently at a constant average rate. It is characterized by its memoryless property, meaning that the probability of an event occurring in the next time unit is independent of the past. The probability density function (PDF) of an exponential distribution is given by:\nInsert formula\nDefine elements\nConsider a scenario where customers arrive at a service point, and the time between successive arrivals follows an exponential distribution. This can be applied to model the inter-arrival times in a queue, the time between calls at a call center, or the time between arrivals of buses at a bus stop.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import expon\n\n# Define parameter\nrate_parameter = 0.5  # Average number of events per unit time\n\n# Generate a sample of 1000 values from an exponential distribution\nsample = expon.rvs(scale=1/rate_parameter, size=1000)\n\n# Plot the histogram of the sample\nplt.hist(sample, bins=30, density=True, alpha=0.7, color='blue')\n\n# Plot the probability density function (PDF)\nx = np.linspace(0, 5, 100)\nplt.plot(x, expon.pdf(x, scale=1/rate_parameter), 'r-', lw=2, label='Exponential PDF')\n\n# Add labels and a legend\nplt.xlabel('Time Between Events')\nplt.ylabel('Probability Density')\nplt.title('Exponential Distribution Example')\nplt.legend()\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "about.html#expected-value-and-variance",
    "href": "about.html#expected-value-and-variance",
    "title": "Probability Theory and Random Variables",
    "section": "Expected Value and Variance",
    "text": "Expected Value and Variance\nThe expected value of a discrete random variable X is a measure of the central tendency and is denoted by E(X). It is calculated as the sum of each possible value of X multiplied by its probability.\nInsert Formula\nAdd an example in die setting\n\n# Define the sample space and probabilities for each outcome\noutcomes = [1, 2, 3, 4, 5, 6]\nprobabilities = [1/6, 1/6, 1/6, 1/6, 1/6, 1/6]\n\n# Calculate the expected value\nexpected_value = sum(x * p for x, p in zip(outcomes, probabilities))\nprint(\"Expected Value:\", expected_value)\n\nExpected Value: 3.5\n\n\nFor a continuous random variable X, the expected value is the integral of x times the probability density function (PDF).\nInsert Formula\nConsider a continuous random variable X with a uniform distribution over the interval [2,8].\n\nfrom scipy.integrate import quad\n\n# Define the PDF for the uniform distribution\ndef uniform_pdf(x):\n    return 1/6 if 2 &lt;= x &lt;= 8 else 0\n\n# Calculate the expected value\nexpected_value_continuous, _ = quad(lambda x: x * uniform_pdf(x), 2, 8)\nprint(\"Expected Value (Continuous):\", expected_value_continuous)\n\nExpected Value (Continuous): 5.0\n\n\nVariance measures the spread or variability of a random variable. For a discrete random variable X, the variance Var(X) is calculated as the sum of the squared differences between each value and the mean, weighted by their probabilities.\nInsert Formula\nAdd an example in a die setting\n\n# Calculate the variance\nvariance = sum((x - expected_value)**2 * p for x, p in zip(outcomes, probabilities))\nprint(\"Variance:\", variance)\n\nVariance: 2.9166666666666665\n\n\nFor a continuous random variable X, the variance is the integral of (x−E(X))^2 times the PDF.\nInsert Formula\nConsider a continuous random variable X with a uniform distribution over the interval [2,8].\n\n# Calculate the variance\nvariance_continuous, _ = quad(lambda x: (x - expected_value_continuous)**2 * uniform_pdf(x), 2, 8)\nprint(\"Variance (Continuous):\", variance_continuous)\n\nVariance (Continuous): 3.0"
  },
  {
    "objectID": "about.html#joint-probability-distributions",
    "href": "about.html#joint-probability-distributions",
    "title": "Probability Theory and Random Variables",
    "section": "Joint Probability Distributions",
    "text": "Joint Probability Distributions\nA joint probability distribution describes the simultaneous behavior of two or more random variables. It provides the probabilities for every possible combination of values that the random variables can take.\nConsider two six-sided dice, X and Y, representing the outcomes of two independent rolls. The joint probability distribution is a table indicating the probability of each possible pair of outcomes (x,y).\n\nimport numpy as np\n\n# Define the sample space and calculate joint probabilities\nsample_space_X = [1, 2, 3, 4, 5, 6]\nsample_space_Y = [1, 2, 3, 4, 5, 6]\n\njoint_probabilities = np.zeros((6, 6))\n\nfor i, x in enumerate(sample_space_X):\n    for j, y in enumerate(sample_space_Y):\n        joint_probabilities[i, j] = 1/36  # Since each outcome is equally likely\n\n# Display the joint probability distribution\nprint(\"Joint Probability Distribution:\")\nprint(joint_probabilities)\n\nJoint Probability Distribution:\n[[0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]]"
  },
  {
    "objectID": "about.html#marginal-probability-distributions",
    "href": "about.html#marginal-probability-distributions",
    "title": "Probability Theory and Random Variables",
    "section": "Marginal Probability Distributions",
    "text": "Marginal Probability Distributions\nMarginal probability distributions focus on the probabilities of individual random variables without considering the others. In the context of joint distributions, these are obtained by summing or integrating over the values of the other variables.\nConsider two six-sided dice, X and Y, representing the outcomes of two independent rolls. The joint probability distribution is a table indicating the probability of each possible pair of outcomes (x,y). Let’s calculate the marginal distributions of X and Y.\n\n# Calculate marginal probabilities\nmarginal_X = np.sum(joint_probabilities, axis=1)\nmarginal_Y = np.sum(joint_probabilities, axis=0)\n\n# Display the marginal probability distributions\nprint(\"\\nMarginal Probability Distribution of X:\")\nprint(marginal_X)\n\nprint(\"\\nMarginal Probability Distribution of Y:\")\nprint(marginal_Y)\n\n\nMarginal Probability Distribution of X:\n[0.16666667 0.16666667 0.16666667 0.16666667 0.16666667 0.16666667]\n\nMarginal Probability Distribution of Y:\n[0.16666667 0.16666667 0.16666667 0.16666667 0.16666667 0.16666667]"
  },
  {
    "objectID": "blog1.html",
    "href": "blog1.html",
    "title": "Probability Theory and Random Variables",
    "section": "",
    "text": "In the tapestry of our daily experiences, uncertainty weaves its intricate threads, creating a landscape where the unknown is an ever-present companion. From deciding whether to carry an umbrella to predicting stock market trends, uncertainty surrounds us, shaping our decisions, actions, and perceptions. It is this pervasive uncertainty that beckons us to explore the realm of probability theory, a powerful tool that empowers us to navigate the unpredictable nature of the world.\nEnter probability theory, a mathematical framework designed to bring order to the chaos of uncertainty. Probability theory provides us with a systematic way to quantify and analyze uncertainty, offering a language to express the likelihood of different outcomes. It serves as a compass, guiding us through the fog of unpredictability and enabling us to make informed decisions in the face of ambiguity.\nAt its core, probability theory explores the likelihood of events occurring in various situations. It equips us with the means to assign numerical values to the uncertainty inherent in any scenario, allowing us to make reasoned predictions and choices. Whether predicting the outcome of a dice roll or estimating the probability of a rare disease occurrence, probability theory provides the analytical tools essential for decision-making in uncertain environments.\nIn the following exploration of probability theory and random variables, we will unravel the intricacies of this indispensable field, delving into its fundamental concepts, applications in real life, and the ways it shapes our understanding of uncertainty. Join us on this journey as we unveil the mathematical underpinnings that empower us to confront the unpredictable with confidence and insight."
  },
  {
    "objectID": "blog1.html#key-probability-rules",
    "href": "blog1.html#key-probability-rules",
    "title": "Probability Theory and Random Variables",
    "section": "Key Probability Rules",
    "text": "Key Probability Rules\n1. Probability of any Event: The probability of an event A in the sample space S, P(A) cannot be negative or more than 1. The probability of all the events in the sample space S adds to 1.\n        P(A) ≥ 0\n\n        P(A) ≤ 1\n\n        P(S) = 1\n2. Addition Rule: The addition rule is a fundamental concept that deals with the probability of the union of two or more events. For two events A and B, the probability of their union (A ∪ B) is given by:\n        P(A ∪ B) = P(A) + P(B) − P(A ∩ B)\nThis formula accounts for the overlap between events A and B to avoid double-counting. The probability of the intersection P(A∩B) is subtracted to ensure accuracy.\n3. Bayes Rule: The multiplication rule governs the probability of the intersection of two events. For two events A and B, the probability of their intersection (A∩B) is given by:\n        P(A ∩ B) = P(A)⋅P(B∣A)\nHere, P(B∣A) represents the conditional probability of event B occurring given that event A has occurred. It expresses the probability of B within the context of A.\n4. Independence Rule: Two events, A and B, are considered independent if the occurrence (or non-occurrence) of one event has no influence on the probability of the other event.\n        P(A ∩ B) = P(A)⋅P(B)\n\n        P(A∣B) = P(A) and P(B∣A) = P(B)\nThese fundamental probability rules lay the groundwork for more complex probability calculations, enabling us to analyze and predict the likelihood of various outcomes in uncertain scenarios. They are essential tools for decision-making and risk assessment in diverse fields, from statistics to finance and beyond."
  },
  {
    "objectID": "blog1.html#types-of-probability",
    "href": "blog1.html#types-of-probability",
    "title": "Probability Theory and Random Variables",
    "section": "Types of Probability",
    "text": "Types of Probability\nProbability comes in various forms, each serving a specific purpose in different contexts. Here are three types of probability: classical, empirical, and subjective, along with real-world examples to illustrate each:\nClassical Probability\nClassical probability is based on equally likely outcomes in a sample space. It assumes that each outcome in the sample space is equally likely to occur.\nExample: Consider a fair coin. The sample space is {Heads, Tails}, and since the coin is fair, each outcome is equally likely. The probability of getting Heads or Tails is 0.5 or 50%.\nEmpircal Probability\nEmpirical probability is based on observed data. It involves calculating the probability of an event by analyzing data collected from actual experiments or observations.\nExample: Suppose you want to know the probability of rain in a particular city. Empirical probability would involve collecting data over time, noting the days with rain, and calculating the ratio of rainy days to the total number of days. If it rained on 30 out of 90 days, the empirical probability would be 0.333 or approximately 33.3%.\nSubjective Probability\nSubjective probability is based on personal judgment, beliefs, or opinions. It reflects an individual’s subjective assessment of the likelihood of an event.\nExample: A doctor might assign a subjective probability to the likelihood of a patient having a particular illness based on their experience, knowledge, and the patient’s symptoms. This probability is subjective and varies from one medical professional to another."
  },
  {
    "objectID": "blog1.html#probability-distributions",
    "href": "blog1.html#probability-distributions",
    "title": "Probability Theory and Random Variables",
    "section": "Probability Distributions",
    "text": "Probability Distributions\nIn probability theory, a probability distribution describes the likelihood of various outcomes in a sample space. It provides a way to model and analyze uncertainty by assigning probabilities to different events. Probability distributions are fundamental tools in probability theory, offering insights into the nature of random variables and helping us make predictions about their behavior. Probability distributions help quantify the uncertainty associated with different outcomes of a random variable. They provide a systematic way to express the likelihood of each possible value.\nProbability distributions form the basis for statistical inference. They allow us to make predictions about the population based on a sample and make informed decisions under uncertainty. Probability distributions are used to model various random processes in diverse fields such as physics, finance, biology, and engineering. They provide a mathematical framework to describe the probabilistic nature of real-world phenomena.\nUniform Distribution\nThe uniform distribution is characterized by all outcomes being equally likely. Each value within a specified range has the same probability of occurring. The probability density function (PDF) for a continuous uniform distribution over the interval [a,b] is given by:\n        f(x)= 1/b−a  for a ≤ x ≤ b\nConsider the example of rolling a fair six-sided die. Each face of the die has an equal chance of landing face up. If we assume the die is unbiased, the outcome of each roll follows a uniform distribution over the discrete values {1,2,3,4,5,6}. Each number has a probability of 1/6 of occurring.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import uniform\n\n# Define the range [a, b]\na = 1\nb = 6\n\n# Generate a sample of 1000 values from a uniform distribution\nsample = uniform.rvs(loc=a, scale=b-a, size=1000)\n\n# Plot the histogram of the sample\nplt.hist(sample, bins=20, density=True, alpha=0.7, color='blue')\n\n# Plot the probability density function (PDF)\nx = np.linspace(a, b, 100)\nplt.plot(x, uniform.pdf(x, loc=a, scale=b-a), 'r-', lw=2, label='Uniform PDF')\n\n# Add labels and a legend\nplt.xlabel('Outcome')\nplt.ylabel('Probability Density')\nplt.title('Uniform Distribution Example')\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\nBinomial Distribution\nThe binomial distribution models the number of successes in a fixed number of independent and identically distributed Bernoulli trials, where each trial has only two possible outcomes (usually termed as “success” and “failure”). The probability mass function (PMF) of a binomial distribution is given by:\n         P(X=k)=( n_p_k ) p^k (1-p)^(n-k)\n​ where: n is the number of trials, k is the number of successes, p is the probability of success on a single trial, and (1−p) is the probability of failure on a single trial.\nConsider the example of flipping a biased coin. Let’s say you have a coin that has a 60% chance of landing heads (success) and a 40% chance of landing tails (failure). If you flip this coin 5 times, you can model the number of heads obtained using a binomial distribution.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import binom\n\n# Define parameters\nn_trials = 5  # Number of coin flips\np_success = 0.6  # Probability of getting heads\n\n# Generate possible outcomes (0 to n_trials)\nx = np.arange(0, n_trials+1)\n\n# Calculate binomial probabilities for each outcome\nbinomial_pmf = binom.pmf(x, n_trials, p_success)\n\n# Plot the probability mass function (PMF)\nplt.stem(x, binomial_pmf, basefmt='b-', linefmt='b-', markerfmt='bo')\nplt.title('Binomial Distribution Example')\nplt.xlabel('Number of Heads')\nplt.ylabel('Probability')\nplt.show()\n\n\n\n\nGaussian Distribution\nThe Gaussian distribution, also known as the normal distribution, is a continuous probability distribution that is symmetric around its mean. It is characterized by its bell-shaped curve. The probability density function (PDF) of a normal distribution is given by:\nf(x;μ,σ)= 1/σroot(2π) e -1/3(x-mu)/sigma^2\nwhere: μ is the mean, σ is the standard deviation\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# Define parameters\nmean_height = 170  # Mean height in centimeters\nstd_deviation = 10  # Standard deviation in centimeters\n\n# Generate a sample of 1000 values from a normal distribution\nsample = np.random.normal(mean_height, std_deviation, 1000)\n\n# Plot the histogram of the sample\nplt.hist(sample, bins=30, density=True, alpha=0.7, color='blue')\n\n# Plot the probability density function (PDF)\nx = np.linspace(mean_height - 4*std_deviation, mean_height + 4*std_deviation, 100)\nplt.plot(x, norm.pdf(x, mean_height, std_deviation), 'r-', lw=2, label='Normal PDF')\n\n# Add labels and a legend\nplt.xlabel('Height (cm)')\nplt.ylabel('Probability Density')\nplt.title('Gaussian Distribution Example')\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\nPoisson Distribution\nThe Poisson distribution models the number of events that occur in a fixed interval of time or space. It is often used for rare events with a known average rate of occurrence. The probability mass function (PMF) of a Poisson distribution is given by:\nInsert formula\nInsert defining elements\nConsider a scenario where you are observing the number of customer arrivals at a store in a given hour, and you know that, on average, 5 customers arrive per hour. The Poisson distribution can be used to model the probability of observing a specific number of customer arrivals in that hour.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import poisson\n\n# Define parameter\naverage_rate = 5  # Average number of events per interval\n\n# Generate possible outcomes (0 to 20 events)\nx = np.arange(0, 21)\n\n# Calculate Poisson probabilities for each outcome\npoisson_pmf = poisson.pmf(x, average_rate)\n\n# Plot the probability mass function (PMF)\nplt.stem(x, poisson_pmf, basefmt='b-', linefmt='b-', markerfmt='bo')\nplt.title('Poisson Distribution Example')\nplt.xlabel('Number of Events')\nplt.ylabel('Probability')\nplt.show()\n\n\n\n\nExponential Distribution\nThe exponential distribution models the time between events in a Poisson process, where events occur continuously and independently at a constant average rate. It is characterized by its memoryless property, meaning that the probability of an event occurring in the next time unit is independent of the past. The probability density function (PDF) of an exponential distribution is given by:\nInsert formula\nDefine elements\nConsider a scenario where customers arrive at a service point, and the time between successive arrivals follows an exponential distribution. This can be applied to model the inter-arrival times in a queue, the time between calls at a call center, or the time between arrivals of buses at a bus stop.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import expon\n\n# Define parameter\nrate_parameter = 0.5  # Average number of events per unit time\n\n# Generate a sample of 1000 values from an exponential distribution\nsample = expon.rvs(scale=1/rate_parameter, size=1000)\n\n# Plot the histogram of the sample\nplt.hist(sample, bins=30, density=True, alpha=0.7, color='blue')\n\n# Plot the probability density function (PDF)\nx = np.linspace(0, 5, 100)\nplt.plot(x, expon.pdf(x, scale=1/rate_parameter), 'r-', lw=2, label='Exponential PDF')\n\n# Add labels and a legend\nplt.xlabel('Time Between Events')\nplt.ylabel('Probability Density')\nplt.title('Exponential Distribution Example')\nplt.legend()\n\n# Show the plot\nplt.show()"
  },
  {
    "objectID": "blog1.html#expected-value-and-variance",
    "href": "blog1.html#expected-value-and-variance",
    "title": "Probability Theory and Random Variables",
    "section": "Expected Value and Variance",
    "text": "Expected Value and Variance\nThe expected value of a discrete random variable X is a measure of the central tendency and is denoted by E(X). It is calculated as the sum of each possible value of X multiplied by its probability.\nInsert Formula\nAdd an example in die setting\n\n# Define the sample space and probabilities for each outcome\noutcomes = [1, 2, 3, 4, 5, 6]\nprobabilities = [1/6, 1/6, 1/6, 1/6, 1/6, 1/6]\n\n# Calculate the expected value\nexpected_value = sum(x * p for x, p in zip(outcomes, probabilities))\nprint(\"Expected Value:\", expected_value)\n\nExpected Value: 3.5\n\n\nFor a continuous random variable X, the expected value is the integral of x times the probability density function (PDF).\nInsert Formula\nConsider a continuous random variable X with a uniform distribution over the interval [2,8].\n\nfrom scipy.integrate import quad\n\n# Define the PDF for the uniform distribution\ndef uniform_pdf(x):\n    return 1/6 if 2 &lt;= x &lt;= 8 else 0\n\n# Calculate the expected value\nexpected_value_continuous, _ = quad(lambda x: x * uniform_pdf(x), 2, 8)\nprint(\"Expected Value (Continuous):\", expected_value_continuous)\n\nExpected Value (Continuous): 5.0\n\n\nVariance measures the spread or variability of a random variable. For a discrete random variable X, the variance Var(X) is calculated as the sum of the squared differences between each value and the mean, weighted by their probabilities.\nInsert Formula\nAdd an example in a die setting\n\n# Calculate the variance\nvariance = sum((x - expected_value)**2 * p for x, p in zip(outcomes, probabilities))\nprint(\"Variance:\", variance)\n\nVariance: 2.9166666666666665\n\n\nFor a continuous random variable X, the variance is the integral of (x−E(X))^2 times the PDF.\nInsert Formula\nConsider a continuous random variable X with a uniform distribution over the interval [2,8].\n\n# Calculate the variance\nvariance_continuous, _ = quad(lambda x: (x - expected_value_continuous)**2 * uniform_pdf(x), 2, 8)\nprint(\"Variance (Continuous):\", variance_continuous)\n\nVariance (Continuous): 3.0"
  },
  {
    "objectID": "blog1.html#joint-probability-distributions",
    "href": "blog1.html#joint-probability-distributions",
    "title": "Probability Theory and Random Variables",
    "section": "Joint Probability Distributions",
    "text": "Joint Probability Distributions\nA joint probability distribution describes the simultaneous behavior of two or more random variables. It provides the probabilities for every possible combination of values that the random variables can take.\nConsider two six-sided dice, X and Y, representing the outcomes of two independent rolls. The joint probability distribution is a table indicating the probability of each possible pair of outcomes (x,y).\n\nimport numpy as np\n\n# Define the sample space and calculate joint probabilities\nsample_space_X = [1, 2, 3, 4, 5, 6]\nsample_space_Y = [1, 2, 3, 4, 5, 6]\n\njoint_probabilities = np.zeros((6, 6))\n\nfor i, x in enumerate(sample_space_X):\n    for j, y in enumerate(sample_space_Y):\n        joint_probabilities[i, j] = 1/36  # Since each outcome is equally likely\n\n# Display the joint probability distribution\nprint(\"Joint Probability Distribution:\")\nprint(joint_probabilities)\n\nJoint Probability Distribution:\n[[0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]\n [0.02777778 0.02777778 0.02777778 0.02777778 0.02777778 0.02777778]]"
  },
  {
    "objectID": "blog1.html#marginal-probability-distributions",
    "href": "blog1.html#marginal-probability-distributions",
    "title": "Probability Theory and Random Variables",
    "section": "Marginal Probability Distributions",
    "text": "Marginal Probability Distributions\nMarginal probability distributions focus on the probabilities of individual random variables without considering the others. In the context of joint distributions, these are obtained by summing or integrating over the values of the other variables.\nConsider two six-sided dice, X and Y, representing the outcomes of two independent rolls. The joint probability distribution is a table indicating the probability of each possible pair of outcomes (x,y). Let’s calculate the marginal distributions of X and Y.\n\n# Calculate marginal probabilities\nmarginal_X = np.sum(joint_probabilities, axis=1)\nmarginal_Y = np.sum(joint_probabilities, axis=0)\n\n# Display the marginal probability distributions\nprint(\"\\nMarginal Probability Distribution of X:\")\nprint(marginal_X)\n\nprint(\"\\nMarginal Probability Distribution of Y:\")\nprint(marginal_Y)\n\n\nMarginal Probability Distribution of X:\n[0.16666667 0.16666667 0.16666667 0.16666667 0.16666667 0.16666667]\n\nMarginal Probability Distribution of Y:\n[0.16666667 0.16666667 0.16666667 0.16666667 0.16666667 0.16666667]"
  },
  {
    "objectID": "about.html#bayes-theorem",
    "href": "about.html#bayes-theorem",
    "title": "Probability Theory and Random Variables",
    "section": "Bayes’ Theorem",
    "text": "Bayes’ Theorem\nBayes’ Theorem is a powerful tool derived from conditional probability. It allows us to update the probability of a hypothesis based on new evidence. The formula is as follows:\nInsert formula P(A∣B) = P(B∣A)⋅P(A)/P(B) Where: P(A∣B) is the posterior probability (probability of A given B). P(B∣A) is the likelihood (probability of B given A). P(A) is the prior probability (probability of A). P(B) is the marginal likelihood (probability of B).\nExample:\nLet’s consider a simple example where we want to predict the probability of a student passing an exam (event A) given that they attended a study session (event B). We have the following probabilities:\nP(A)=0.7 (prior probability of passing) P(B∣A)=0.8 (likelihood of attending a study session given passing) P(B∣¬A)=0.4 (likelihood of attending a study session given not passing)\n\n# Define probabilities\nP_A = 0.7  # Prior probability of passing\nP_B_given_A = 0.8  # Likelihood of attending a study session given passing\nP_B_given_not_A = 0.4  # Likelihood of attending a study session given not passing\n\n# Calculate marginal likelihood P(B)\nP_B = P_B_given_A * P_A + P_B_given_not_A * (1 - P_A)\n\n# Calculate posterior probability P(A|B) using Bayes' Theorem\nP_A_given_B = (P_B_given_A * P_A) / P_B\n\nprint(f\"The probability of passing given attending a study session is: {P_A_given_B:.2f}\")\n\nThe probability of passing given attending a study session is: 0.82\n\n\nIn this example, we use Bayes’ Theorem to update our prior belief (probability of passing) based on new evidence (attending a study session). The calculated posterior probability gives us an updated estimate of the likelihood of passing given the observed evidence.\nThis demonstrates how conditional probability and Bayes’ Theorem are applied in machine learning for making predictions and updating beliefs based on new information."
  }
]